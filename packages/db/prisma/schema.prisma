generator client {
  provider = "prisma-client-js"
}

generator py {
  provider             = "prisma-client-py"
  interface            = "asyncio"
  recursive_type_depth = "-1"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ABILITY SYSTEM (NEW)
// ============================================================================

model Ability {
  id             Int      @id @default(autoincrement())
  name           String // Display name with color codes (XML-Lite format)
  plainName      String   @unique @map("plain_name") // Plain text name - unique identifier
  description    String?
  abilityType    String   @default("SPELL") // Type: SPELL, SKILL, SONG, CHANT
  schoolId       Int?     @map("school_id")
  minPosition    Position @default(STANDING)
  violent        Boolean  @default(false)
  castTimeRounds Int      @default(1) @map("cast_time_rounds")
  cooldownMs     Int      @default(0) @map("cooldown_ms")
  inCombatOnly   Boolean  @default(false) @map("in_combat_only")
  combatOk       Boolean  @default(true) @map("combat_ok") // Can be used during combat
  isArea         Boolean  @default(false) @map("is_area")
  isToggle       Boolean  @default(false) @map("is_toggle") // Toggle ability (on/off state)
  notes          String?
  tags           String[] @default([])
  luaScript      String?  @map("lua_script") @db.Text

  // --- Spell metadata ---
  sphere           SpellSphere? // Spell sphere: fire, water, healing, etc.
  damageType       ElementType? @map("damage_type") // Primary damage type for display
  pages            Int? // Spellbook pages required to scribe
  memorizationTime Int          @default(0) @map("memorization_time") // Additional memorization rounds
  questOnly        Boolean      @default(false) @map("quest_only") // Quest-restricted ability
  humanoidOnly     Boolean      @default(false) @map("humanoid_only") // Only available to humanoids

  // --- Stealth & Visibility ---
  contestedVisibility Boolean @default(false) @map("contested_visibility") // Room messages require perception checks
  visibilityCheck     String? @map("visibility_check") // Check formula: "stealth vs perception"

  // --- Relationships ---
  effects             AbilityEffect[]
  school              AbilitySchool?           @relation(fields: [schoolId], references: [id])
  characterAbilities  CharacterAbilities[]
  mobAbilities        MobAbilities[]
  classAbilities      ClassAbilities[]
  classSkills         ClassSkills[]
  components          AbilityComponent[]
  damageComponents    AbilityDamageComponent[] // Multi-element damage (e.g., Fireball = FIRE + FORCE)
  messages            AbilityMessages?
  restrictions        AbilityRestrictions?
  savingThrows        AbilitySavingThrow[]
  targeting           AbilityTargeting?
  raceAbilities       RaceAbilities[]
  objectAbilities     ObjectAbilities[]
  commands            Command[] // Commands that trigger this ability
  // Quest system relations
  questRewards        QuestRewards[]
  questObjectives     QuestObjectives[]
  questTriggerAbility Quests[]                 @relation("questTriggerAbility")
  // Shop system relations
  shopAbilities       ShopAbilities[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
}

model ToolboxCategory {
  id           Int      @id @default(autoincrement())
  name         String   @unique // Display name: "Damage & Healing"
  colour       String // Hex color: "#e53935"
  displayOrder Int      @map("display_order")
  effects      Effect[]

  @@map("ToolboxCategory")
}

model Effect {
  id            Int                @id @default(autoincrement())
  name          String             @unique
  description   String?
  effectType    String // e.g., "damage", "heal", "status", "crowd_control"
  tags          String[] // e.g., ["damage", "elemental", "fire"] for filtering
  defaultParams Json               @default("{}") @map("default_params")
  paramSchema   Json?              @map("param_schema") // JSON Schema for validation
  categoryId    Int?               @map("category_id")
  category      ToolboxCategory?   @relation(fields: [categoryId], references: [id])
  abilities     AbilityEffect[]
  consumables   ConsumableEffect[] // Applied when consuming liquids, foods, potions, etc.

  // Effect relationships
  grantsImmunityTo   Effect[]       @relation("EffectImmunity")
  immuneFrom         Effect[]       @relation("EffectImmunity")
  presenceOverride   String?        @map("presence_override") // "{actor} floats in the air..."

  // Positions that apply this effect (e.g., UNDERWATER applies DROWNING)
  appliedByPositions PositionData[] @relation("PositionAppliesEffect")

  // Rooms that apply this effect as environmental hazard
  appliedByRooms     RoomEnvironmentalEffect[]

  // Effect timing (for applied effects like DROWNING)
  delaySeconds     Int?            @map("delay_seconds")     // Grace period before effect kicks in
  tickIntervalSec  Int?            @map("tick_interval_sec") // How often effect ticks

  // Lua scripts for effect behavior
  onApply          String?         @map("on_apply")  // Lua: actor:send("You begin to drown!")
  onTick           String?         @map("on_tick")   // Lua: actor:damage(10, "drowning")
  onRemove         String?         @map("on_remove") // Lua: actor:send("You gasp for air!")

  // Action restrictions when effect is active
  preventsSpeaking Boolean         @default(false) @map("prevents_speaking")
  preventsCasting  Boolean         @default(false) @map("prevents_casting")
  preventsMovement Boolean         @default(false) @map("prevents_movement")

  // Relations to entities that can have this effect
  characterEffects   CharacterEffects[]   // Runtime effects on characters
  mobDefaultEffects  MobDefaultEffects[]  // Default effects mobs always have
  objectEffects      ObjectEffects[]      // Effects granted by objects when worn/held
  raceEffects        RaceEffects[]        // Permanent effects for races

  @@index([effectType])
  @@index([categoryId])
}

model AbilityEffect {
  abilityId      Int     @map("ability_id")
  ability        Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)
  effectId       Int     @map("effect_id")
  effect         Effect  @relation(fields: [effectId], references: [id], onDelete: Cascade)
  overrideParams Json?   @map("override_params")
  order          Int     @default(0)
  trigger        String? // e.g., "on_cast", "on_hit", "on_tick"
  chancePct      Int     @default(100) @map("chance_pct")
  condition      String? // Lua expression: "target.isUndead"

  @@id([abilityId, effectId, order])
}

model AbilitySchool {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String?
  abilities   Ability[]
}

model AbilityRestrictions {
  id        Int     @id @default(autoincrement())
  abilityId Int     @unique @map("ability_id")
  ability   Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  requirements         Json[]  @default([])
  customRequirementLua String? @map("custom_requirement_lua")
}

model AbilitySavingThrow {
  id           Int      @id @default(autoincrement())
  abilityId    Int      @map("ability_id")
  ability      Ability  @relation(fields: [abilityId], references: [id], onDelete: Cascade)
  saveType     SaveType @default(WILL)
  dcFormula    String   @map("dc_formula")
  onSaveAction Json     @default("\"NEGATE\"") @map("on_save_action")
}

model AbilityTargeting {
  id           Int          @id @default(autoincrement())
  abilityId    Int          @unique @map("ability_id")
  ability      Ability      @relation(fields: [abilityId], references: [id], onDelete: Cascade)
  validTargets TargetType[] @default([SELF]) @map("valid_targets")
  scope        TargetScope  @default(SINGLE)
  scopePattern String?      @map("scope_pattern")
  maxTargets   Int          @default(1) @map("max_targets")
  range        Int          @default(0)
  requireLos   Boolean      @default(false) @map("require_los")
}

model AbilityMessages {
  id              Int     @id @default(autoincrement())
  abilityId       Int     @unique @map("ability_id")
  startToCaster   String? @map("start_to_caster")
  startToVictim   String? @map("start_to_victim")
  startToRoom     String? @map("start_to_room")
  successToCaster String? @map("success_to_caster")
  successToVictim String? @map("success_to_victim")
  successToRoom   String? @map("success_to_room")
  successToSelf   String? @map("success_to_self") // Message to caster when casting on self
  successSelfRoom String? @map("success_self_room") // Room message when caster targets self
  failToCaster    String? @map("fail_to_caster")
  failToVictim    String? @map("fail_to_victim")
  failToRoom      String? @map("fail_to_room")
  wearoffToTarget String? @map("wearoff_to_target")
  wearoffToRoom   String? @map("wearoff_to_room")
  lookMessage     String? @map("look_message") // Message shown when looking at someone with this effect
  ability         Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)
}

model AbilityComponent {
  id        Int     @id @default(autoincrement())
  abilityId Int     @map("ability_id")
  objectId  Int     @map("object_id")
  consumed  Boolean @default(false)
  required  Boolean @default(true)
  ability   Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)
}

// Multi-component damage for abilities (e.g., Fireball = 70% FIRE + 30% FORCE)
model AbilityDamageComponent {
  id            Int         @id @default(autoincrement())
  abilityId     Int         @map("ability_id")
  element       ElementType
  damageFormula String      @map("damage_formula") // e.g., "8d6", "2d6+level"
  percentage    Int         @default(100) // % of total damage (should sum to 100)
  sequence      Int         @default(0) // order of application

  ability Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@index([abilityId])
}

model ObjectAbilities {
  id           Int     @id @default(autoincrement())
  abilityId    Int     @map("ability_id")
  level        Int     @default(1)
  objectZoneId Int     @map("object_zone_id")
  objectId     Int     @map("object_id")
  charges      Int?
  objects      Objects @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  ability      Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([objectZoneId, objectId, abilityId])
}

model ClassAbilityCircles {
  id             Int            @id @default(autoincrement())
  classId        Int            @map("class_id")
  circle         Int
  minLevel       Int            @map("min_level")
  characterClass CharacterClass @relation(fields: [classId], references: [id], onDelete: Cascade)

  @@unique([classId, circle])
}

/// Global spell slot progression table
/// Determines how many spell slots are available at each level for each circle
/// Same for all classes - class differences come from when they access circles (ClassAbilityCircles.minLevel)
model SpellSlotProgression {
  id     Int @id @default(autoincrement())
  level  Int // Character level (1-100)
  circle Int // Spell circle (1-14)
  slots  Int // Number of slots available

  @@unique([level, circle])
  @@map("SpellSlotProgression")
}

model ClassAbilities {
  id             Int            @id @default(autoincrement())
  classId        Int            @map("class_id")
  abilityId      Int            @map("ability_id")
  circle         Int
  proficiencyCap Int            @default(100) @map("proficiency_cap") // Max trainable proficiency (0-100)
  characterClass CharacterClass @relation(fields: [classId], references: [id], onDelete: Cascade)
  ability        Ability        @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([classId, abilityId])
}

model ClassSkills {
  id             Int            @id @default(autoincrement())
  classId        Int            @map("class_id")
  abilityId      Int            @map("ability_id")
  minLevel       Int            @map("min_level")
  proficiencyCap Int            @default(100) @map("proficiency_cap") // Max trainable proficiency (0-100)
  characterClass CharacterClass @relation(fields: [classId], references: [id], onDelete: Cascade)
  ability        Ability        @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([classId, abilityId])
}

model CharacterAbilities {
  id          Int        @id @default(autoincrement())
  characterId String     @map("character_id")
  abilityId   Int        @map("ability_id")
  known       Boolean    @default(false)
  proficiency Int        @default(0)
  lastUsed    DateTime?  @map("last_used")
  character   Characters @relation(fields: [characterId], references: [id], onDelete: Cascade)
  ability     Ability    @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([characterId, abilityId])
}

model MobAbilities {
  id        Int     @id @default(autoincrement())
  mobZoneId Int     @map("mob_zone_id")
  mobId     Int     @map("mob_id")
  abilityId Int     @map("ability_id")
  circle    Int     @default(1)
  known     Boolean @default(true)
  mob       Mobs    @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  ability   Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([mobZoneId, mobId, abilityId])
}

// ============================================================================
// EXISTING MODELS
// ============================================================================

model CharacterClass {
  id          Int     @id @default(autoincrement())
  name        String // Display name with color codes (XML-Lite format)
  plainName   String  @unique @map("plain_name") // Plain text name - unique identifier
  description String?
  hitDice     String  @default("1d8") @map("hit_dice")
  primaryStat String? @map("primary_stat")

  // Combat modifiers - class-based bonuses
  bonusHitroll  Int   @default(0) @map("bonus_hitroll")
  bonusDamroll  Int   @default(0) @map("bonus_damroll")
  baseAc        Int   @default(100) @map("base_ac") // Base armor class (100 = standard)
  hpPerLevel    Int   @default(10) @map("hp_per_level")
  thac0Base     Int   @default(20) @map("thac0_base") // THAC0 at level 1
  thac0PerLevel Float @default(1.0) @map("thac0_per_level") // THAC0 improvement per level

  // Elemental resistances: JSON object { "FIRE": 25, "MENTAL": -25 }
  // Values: -100 (2x damage) to 100 (immune). Stacks multiplicatively with race/gear.
  resistances Json? @default("{}")

  createdAt           DateTime              @default(now()) @map("created_at")
  updatedAt           DateTime              @updatedAt @map("updated_at")
  characters          Characters[]
  classSkills         ClassSkills[]
  classAbilities      ClassAbilities[]
  classAbilityCircles ClassAbilityCircles[]
  mobs                Mobs[]

  @@map("Class")
}

// ============================================================================
// HELP SYSTEM
// ============================================================================

model HelpEntry {
  id       Int      @id @default(autoincrement())
  keywords String[] // Multiple keywords for lookup (e.g., ["FIREBALL", "FIRE BALL"])
  title    String // Primary display title
  content  String   @db.Text // Full help text content
  minLevel Int      @default(0) @map("min_level") // 0 = all players, 100+ = immortal only
  category String? // Optional category for organization (e.g., "spell", "skill", "command")

  // Parsed metadata (for spell/skill entries)
  usage    String? // Usage syntax
  duration String? // Duration description
  sphere   String? // Spell sphere (fire, water, healing, etc.)
  classes  Json? // Class/circle requirements as JSON (e.g., {"Pyromancer": 7, "Sorcerer": 3})

  // Tracking
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  sourceFile String?  @map("source_file") // Original help file this came from

  @@index([keywords], type: Gin)
  @@map("HelpEntry")
}

model AuditLogs {
  id         String   @id
  action     String
  entityType String   @map("entity_type")
  entityId   String   @map("entity_id")
  oldValues  Json?    @map("old_values")
  newValues  Json?    @map("new_values")
  userId     String   @map("user_id")
  createdAt  DateTime @default(now()) @map("created_at")
  users      Users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model BanRecords {
  id           String    @id
  userId       String    @map("user_id")
  bannedBy     String    @map("banned_by")
  reason       String
  bannedAt     DateTime  @default(now()) @map("banned_at")
  expiresAt    DateTime? @map("expires_at")
  unbannedAt   DateTime? @map("unbanned_at")
  unbannedBy   String?   @map("unbanned_by")
  active       Boolean   @default(true)
  bannedByUser Users     @relation("bannedByUser", fields: [bannedBy], references: [id])
  user         Users     @relation("userBanRecords", fields: [userId], references: [id], onDelete: Cascade)

  @@index([active])
  @@index([bannedAt])
  @@index([bannedBy])
  @@index([userId])
}

model ChangeLogs {
  id          Int      @id @default(autoincrement())
  entityType  String   @map("entity_type")
  entityId    String   @map("entity_id")
  action      String
  changes     Json     @default("{}")
  userId      String   @map("user_id")
  timestamp   DateTime @default(now())
  description String?
  users       Users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([userId, timestamp])
}

// Runtime effects currently applied to a character (with duration, strength, etc.)
model CharacterEffects {
  id           Int        @id @default(autoincrement())
  characterId  String     @map("character_id")
  effectId     Int        @map("effect_id") // Foreign key to Effect table
  duration     Int? // Remaining duration in seconds (null = permanent)
  strength     Int        @default(1) // Effect strength/stacks
  modifierData Json       @default("{}") @map("modifier_data") // Additional parameters
  sourceType   String?    @map("source_type") // "ability", "item", "room", etc.
  sourceId     Int?       @map("source_id") // ID of source
  appliedAt    DateTime   @default(now()) @map("applied_at")
  expiresAt    DateTime?  @map("expires_at")

  characters   Characters @relation(fields: [characterId], references: [id], onDelete: Cascade)
  effect       Effect     @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@index([characterId])
  @@index([effectId])
}

// Default effects that mobs always spawn with (e.g., a ghost mob has INVISIBLE effect)
model MobDefaultEffects {
  id           Int      @id @default(autoincrement())
  mobZoneId    Int      @map("mob_zone_id")
  mobId        Int      @map("mob_id")
  effectId     Int      @map("effect_id")
  strength     Int      @default(1)         // Effect strength/stacks
  modifierData Json     @default("{}") @map("modifier_data") // Additional parameters

  mob          Mobs     @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  effect       Effect   @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@unique([mobZoneId, mobId, effectId])
  @@index([mobZoneId, mobId])
  @@index([effectId])
}

// Effects granted by objects when worn/held (e.g., ring of invisibility grants INVISIBLE)
model ObjectEffects {
  id           Int      @id @default(autoincrement())
  objectZoneId Int      @map("object_zone_id")
  objectId     Int      @map("object_id")
  effectId     Int      @map("effect_id")
  strength     Int      @default(1)         // Effect strength/stacks
  modifierData Json     @default("{}") @map("modifier_data") // Additional parameters
  wearLocation WearFlag? @map("wear_location") // Only apply when worn in specific slot (null = any)

  object       Objects  @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  effect       Effect   @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@unique([objectZoneId, objectId, effectId])
  @@index([objectZoneId, objectId])
  @@index([effectId])
}

// Permanent effects granted to races (e.g., INFRAVISION for elves)
model RaceEffects {
  id           Int      @id @default(autoincrement())
  race         Race
  effectId     Int      @map("effect_id")
  strength     Int      @default(1)         // Effect strength/stacks
  modifierData Json     @default("{}") @map("modifier_data") // Additional parameters

  raceData     Races    @relation(fields: [race], references: [race], onDelete: Cascade)
  effect       Effect   @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@unique([race, effectId])
  @@index([race])
  @@index([effectId])
}

model CharacterItems {
  id                       Int              @id @default(autoincrement())
  characterId              String           @map("character_id")
  objectZoneId             Int              @map("object_zone_id")
  objectId                 Int              @map("object_id")
  containerId              Int?             @map("container_id")
  equippedLocation         String?          @map("equipped_location")
  condition                Int              @default(100)
  charges                  Int              @default(-1)
  instanceFlags            ItemInstanceFlag[] @default([]) @map("instance_flags")
  customName               String?          @map("custom_name")
  customExamineDescription String?          @map("custom_examine_description")
  customValues             Json             @default("{}") @map("custom_values")
  // Liquid container state (for drinks)
  liquidType               String?          @map("liquid_type")
  liquidRemaining          Int              @default(0) @map("liquid_remaining")
  liquidEffects            Int[]            @default([]) @map("liquid_effects") // Effect IDs applied to this liquid instance
  liquidIdentified         Boolean          @default(false) @map("liquid_identified")
  createdAt                DateTime         @default(now()) @map("created_at")
  updatedAt                DateTime         @map("updated_at")
  characters               Characters       @relation(fields: [characterId], references: [id], onDelete: Cascade)
  container                CharacterItems?  @relation("itemContainer", fields: [containerId], references: [id])
  containedItems           CharacterItems[] @relation("itemContainer")
  objects                  Objects          @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
}

model Characters {
  id                    String               @id
  name                  String               @unique
  level                 Int                  @default(1)
  alignment             Int                  @default(0)
  strength              Int                  @default(13)
  intelligence          Int                  @default(13)
  wisdom                Int                  @default(13)
  dexterity             Int                  @default(13)
  constitution          Int                  @default(13)
  charisma              Int                  @default(13)
  luck                  Int                  @default(13)
  hitPoints             Int                  @default(100) @map("hit_points")
  stamina               Int                  @default(100)
  hitPointsMax          Int                  @default(100) @map("hit_points_max")
  staminaMax            Int                  @default(100) @map("stamina_max")
  wealth                BigInt               @default(0) // Stored in copper units
  bankWealth            BigInt               @default(0) @map("bank_wealth") // Bank balance in copper
  averageStats          Int                  @default(13) @map("average_stats")
  passwordHash          String               @default("") @map("password_hash")
  raceType              String               @default("human") @map("race_type")
  race                  Race                 @default(HUMAN)
  gender                String               @default("neutral")
  playerClass           String?              @map("player_class")
  height                Int?
  weight                Int?
  baseHeight            Int?                 @map("base_height")
  baseWeight            Int?                 @map("base_weight")
  baseSize              Int                  @default(0) @map("base_size")
  currentSize           Int                  @default(0) @map("current_size")
  hitRoll               Int                  @default(0) @map("hit_roll")
  damageRoll            Int                  @default(0) @map("damage_roll")
  armorClass            Int                  @default(10) @map("armor_class")
  currentRoomZoneId     Int?                 @map("current_room_zone_id")
  currentRoomId         Int?                 @map("current_room_id")
  recallRoomZoneId      Int?                 @map("recall_room_zone_id")
  recallRoomId          Int?                 @map("recall_room_id")
  lastLogin             DateTime?            @map("last_login")
  timePlayed            Int                  @default(0) @map("time_played")
  isOnline              Boolean              @default(false) @map("is_online")
  hunger                Int                  @default(0)
  thirst                Int                  @default(0)
  description           String?
  title                 String?
  prompt                String               @default("<%%h/%%Hhp %%v/%%Vmv>")
  pageLength            Int                  @default(25) @map("page_length")
  playerFlags           PlayerFlag[]         @default([]) @map("player_flags")
  permissions           Permission[]         @default([]) @map("permissions") // Direct permission grants beyond level
  olcZones              Int[]                @default([]) @map("olc_zones")
  invisLevel            Int                  @default(0) @map("invis_level")
  wimpyThreshold        Int                  @default(0) @map("wimpy_threshold")
  freezeLevel           Int?                 @map("freeze_level")
  autoInvisLevel        Int                  @default(0) @map("auto_invis_level")
  birthTime             DateTime             @default(now()) @map("birth_time")
  userId                String?              @map("user_id")
  createdAt             DateTime             @default(now()) @map("created_at")
  updatedAt             DateTime             @updatedAt @map("updated_at")
  // Soft delete support
  deletedAt             DateTime?            @map("deleted_at")
  deletionReason        String?              @map("deletion_reason")
  classId               Int?                 @map("class_id")
  experience            Int                  @default(0)
  skillPoints           Int                  @default(0) @map("skill_points")
  // Position state (persisted so ghost state survives logout)
  position              Position             @default(STANDING)
  characterAliases      CharacterAliases[]
  characterEffects      CharacterEffects[]
  characterItems        CharacterItems[]
  characterAbilities    CharacterAbilities[]
  characterPets         CharacterPets[]
  characterClass        CharacterClass?      @relation(fields: [classId], references: [id])
  users                 Users?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  accountItemsStored    AccountItems[] // Items this character deposited to account storage
  mailSent              PlayerMail[]         @relation("mailSent")
  mailReceived          PlayerMail[]         @relation("mailReceived")
  mailWealthRetrievedBy PlayerMail[]         @relation("mailWealthRetrievedBy")
  mailObjectRetrievedBy PlayerMail[]         @relation("mailObjectRetrievedBy")
  // Quest progress tracking
  characterQuests       CharacterQuests[]
}

model CharacterAliases {
  id          Int        @id @default(autoincrement())
  characterId String     @map("character_id")
  alias       String
  command     String
  characters  Characters @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([characterId, alias])
}

model CharacterPets {
  id                 String   @id @default(uuid())
  characterId        String   @map("character_id")
  mobPrototypeZoneId Int      @map("mob_prototype_zone_id")
  mobPrototypeVnum   Int      @map("mob_prototype_vnum")
  name               String // Pet's current name (can be customized)
  customDescription  String?  @map("custom_description") @db.Text
  createdAt          DateTime @default(now()) @map("created_at")

  // Relationships
  character    Characters @relation(fields: [characterId], references: [id], onDelete: Cascade)
  mobPrototype Mobs       @relation(fields: [mobPrototypeZoneId, mobPrototypeVnum], references: [zoneId, id], onDelete: Cascade)

  @@index([characterId])
  @@index([mobPrototypeZoneId, mobPrototypeVnum])
}

model EquipmentSetItems {
  id             Int           @id @default(autoincrement())
  equipmentSetId Int           @map("equipment_set_id")
  objectZoneId   Int           @map("object_zone_id")
  objectId       Int           @map("object_id")
  slot           String?
  quantity       Int           @default(1)
  probability    Float         @default(1.0)
  equipment_sets EquipmentSets @relation(fields: [equipmentSetId], references: [id], onDelete: Cascade)
  objects        Objects       @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
}

model EquipmentSets {
  id                Int                 @id @default(autoincrement())
  name              String
  description       String?
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")
  equipmentSetItems EquipmentSetItems[]
  mobEquipmentSets  MobEquipmentSets[]
}

model MobCarrying {
  id           Int       @id @default(autoincrement())
  max          Int       @default(1)
  name         String?
  objectZoneId Int       @map("object_zone_id")
  objectId     Int       @map("object_id")
  resetId      Int       @map("reset_id")
  // When true, item is decorative only - cannot be looted from corpse or stolen
  // Different from TEMPORARY object flag (which IS lootable but doesn't persist through logout)
  decorative   Boolean   @default(false)
  objects      Objects   @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  mob_resets   MobResets @relation(fields: [resetId], references: [id], onDelete: Cascade)
}

model MobEquipmentSets {
  id             Int           @id @default(autoincrement())
  mobResetId     Int           @map("mob_reset_id")
  equipmentSetId Int           @map("equipment_set_id")
  probability    Float         @default(1.0)
  equipment_sets EquipmentSets @relation(fields: [equipmentSetId], references: [id], onDelete: Cascade)
  mob_resets     MobResets     @relation(fields: [mobResetId], references: [id], onDelete: Cascade)

  @@unique([mobResetId, equipmentSetId])
}

model MobResetEquipment {
  id           Int       @id @default(autoincrement())
  maxInstances Int       @default(1) @map("max_instances")
  wearLocation String?   @map("wear_location")
  objectZoneId Int       @map("object_zone_id")
  objectId     Int       @map("object_id")
  resetId      Int       @map("reset_id")
  probability  Float     @default(1.0)
  // When true, equipment is decorative only - cannot be looted from corpse or stolen
  // Allows mobs to appear fully equipped without dropping piles of gear
  // Different from TEMPORARY object flag (which IS lootable but doesn't persist through logout)
  decorative   Boolean   @default(false)
  objects      Objects   @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  mob_resets   MobResets @relation(fields: [resetId], references: [id], onDelete: Cascade)
}

model MobResets {
  id                Int                 @id @default(autoincrement())
  maxInstances      Int                 @default(1) @map("max_instances")
  comment           String?
  mobZoneId         Int                 @map("mob_zone_id")
  mobId             Int                 @map("mob_id")
  roomZoneId        Int                 @map("room_zone_id")
  roomId            Int                 @map("room_id")
  zoneId            Int                 @map("zone_id")
  probability       Float               @default(1.0)
  resetBehavior     String              @default("PERSISTENT") @map("reset_behavior")
  mobCarrying       MobCarrying[]
  mobEquipmentSets  MobEquipmentSets[]
  mobResetEquipment MobResetEquipment[]
  mobs              Mobs                @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  rooms             Room                @relation(fields: [roomZoneId, roomId], references: [zoneId, id], onDelete: Cascade)
  zones             Zones               @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  spawnConditions   SpawnConditions[]
}

model Mobs {
  id                      Int
  keywords                String[]
  name                    String   @map("name")
  plainName               String   @default("") @map("plain_name")
  baseName                String   @default("") @map("base_name") // Name without article (with colors)
  plainBaseName           String   @default("") @map("plain_base_name") // Name without article (plain text)
  article                 String?  @map("article") // null=a/an, "the", "some", ""=none
  roomDescription         String   @map("room_description")
  plainRoomDescription    String   @default("") @map("plain_room_description")
  examineDescription      String   @map("examine_description")
  plainExamineDescription String   @default("") @map("plain_examine_description")
  alignment               Int      @default(0)
  level                   Int      @default(1)

  // MOB ROLE CLASSIFICATION
  role MobRole @default(TRASH)

  // LEGACY COMBAT STATS (to be removed after migration)
  armorClass Int @default(0) @map("armor_class")
  hitRoll    Int @default(0) @map("hit_roll")

  // NEW OFFENSIVE STATS
  accuracy           Int @default(0)
  attackPower        Int @default(0) @map("attack_power")
  spellPower         Int @default(0) @map("spell_power")
  penetrationFlat    Int @default(0) @map("penetration_flat")
  penetrationPercent Int @default(0) @map("penetration_percent")

  // NEW DEFENSIVE STATS
  evasion                Int @default(0)
  armorRating            Int @default(0) @map("armor_rating")
  damageReductionPercent Int @default(0) @map("damage_reduction_percent")
  soak                   Int @default(0)
  hardness               Int @default(0)
  wardPercent            Int @default(0) @map("ward_percent")

  // RESISTANCES (damage types AND effects)
  // JSON object mapping damage types and effect names to resistance percentages
  // Scale: -100 = absorb (heals), 0 = immune, 100 = normal damage, 200 = double damage
  // Examples: {"FIRE": 0, "COLD": 200, "charm": 0, "knockdown": 50}
  // Supports DamageType enum values AND effect type names from effects.json
  resistances Json @default("{}")

  move            Int          @default(0)
  hpDiceNum       Int          @default(0) @map("hp_dice_num")
  hpDiceSize      Int          @default(0) @map("hp_dice_size")
  hpDiceBonus     Int          @default(0) @map("hp_dice_bonus")
  damageDiceNum   Int          @default(0) @map("damage_dice_num")
  damageDiceSize  Int          @default(0) @map("damage_dice_size")
  damageDiceBonus Int          @default(0) @map("damage_dice_bonus")
  wealth          BigInt       @default(0) // Stored in copper units
  raceAlign       Int          @default(0) @map("race_align")
  averageStats    Int          @default(13) @map("average_stats")
  estimatedHp     Int          @default(0) @map("estimated_hp")
  strength        Int          @default(13)
  intelligence    Int          @default(13)
  wisdom          Int          @default(13)
  dexterity       Int          @default(13)
  constitution    Int          @default(13)
  charisma        Int          @default(13)
  perception      Int          @default(0)
  concealment     Int          @default(0)
  zoneId          Int          @map("zone_id")
  createdAt       DateTime     @default(now()) @map("created_at")
  updatedAt       DateTime     @updatedAt @map("updated_at")
  deletedAt       DateTime?    @map("deleted_at")
  createdBy       String?      @map("created_by")
  updatedBy       String?      @map("updated_by")
  classId         Int?         @map("class_id")
  race            Race         @default(HUMANOID)
  position        Position     @default(STANDING)
  defaultPosition     Position     @default(STANDING)
  movementMode        MovementMode @default(NORMAL) @map("movement_mode")
  defaultMovementMode MovementMode @default(NORMAL) @map("default_movement_mode")
  gender              Gender       @default(NEUTRAL)
  size            Size         @default(MEDIUM)
  lifeForce       LifeForce    @default(LIFE)
  composition     Composition  @default(FLESH)
  stance          Stance       @default(ALERT)
  damageType      DamageType   @default(HIT)

  // FLAG REORGANIZATION FIELDS (NEW)
  // Organized flag system - replaces monolithic mobFlags
  traits      MobTrait[]      @default([]) // What mob IS (identity)
  behaviors   MobBehavior[]   @default([]) // How mob ACTS
  professions MobProfession[] @default([]) // Services mob provides (BANKER, SHOPKEEPER, etc.)

  // Mount system: How rider appears when mounted on this mob
  // e.g., "{actor} circles overhead astride {mount}." or "{actor} rides {mount}."
  riderPresenceMessage String? @map("rider_presence_message")

  // Aggression formula (Lua expression) - who mob attacks on sight
  // Examples: "true" (attacks all), "target.alignment < -350", "target.race == 'ELF'"
  aggressionFormula String? @map("aggression_formula")

  // Activity restrictions (Lua formula)
  // Examples: "not world.is_sunny()", "time.hour >= 20", "room.is_indoors()"
  activityRestrictions String? @map("activity_restrictions")

  mobResets          MobResets[]
  mobAbilities       MobAbilities[]
  defaultEffects     MobDefaultEffects[] // Effects mob always spawns with
  characterPets      CharacterPets[]
  characterClass     CharacterClass?   @relation(fields: [classId], references: [id])
  zones              Zones             @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  shops              Shops[]
  mobTriggers        MobTriggers[] // Trigger attachments via junction table
  shopMobs           ShopMobs[] // Mobs for sale at pet/mount shops
  // Quest system relations
  questsAsTrigger    Quests[]          @relation("questTriggerMob") // MOB trigger type quests
  objectiveTargetMob QuestObjectives[] @relation("objectiveTargetMob")
  objectiveDeliverTo QuestObjectives[] @relation("objectiveDeliverTo")
  Triggers           Triggers[]

  @@id([zoneId, id])
  @@index([name])
  @@index([zoneId, name])
  @@index([plainName])
  @@index([plainRoomDescription])
  @@index([plainExamineDescription])
}

model ObjectAffects {
  id           Int     @id @default(autoincrement())
  location     String
  modifier     Int
  objectZoneId Int     @map("object_zone_id")
  objectId     Int     @map("object_id")
  objects      Objects @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
}

model ObjectExtraDescriptions {
  id           Int      @id @default(autoincrement())
  keywords     String[]
  description  String
  objectZoneId Int      @map("object_zone_id")
  objectId     Int      @map("object_id")
  objects      Objects  @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
}

// Resistance bonuses granted by equipment (e.g., Ring of Fire Resistance)
model ObjectResistance {
  id              Int         @id @default(autoincrement())
  objectZoneId    Int         @map("object_zone_id")
  objectId        Int         @map("object_id")
  element         ElementType
  value           Int // -100 to 100 normally, >100 for absorption items
  allowAbsorption Boolean     @default(false) @map("allow_absorption") // Can exceed 100%?

  object Objects @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)

  @@unique([objectZoneId, objectId, element])
}

// ObjectResets: Root objects that spawn directly in rooms
// Nested objects (inside containers) are defined in ObjectResetContents
model ObjectResets {
  id              Int                   @id @default(autoincrement())
  maxInstances    Int                   @default(1) @map("max_instances")
  comment         String?
  objectZoneId    Int                   @map("object_zone_id")
  objectId        Int                   @map("object_id")
  roomZoneId      Int                   @map("room_zone_id")
  roomId          Int                   @map("room_id")
  zoneId          Int                   @map("zone_id")
  probability     Float                 @default(1.0)
  resetBehavior   String                @default("PERSISTENT") @map("reset_behavior")
  objects         Objects               @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  rooms           Room                  @relation(fields: [roomZoneId, roomId], references: [zoneId, id], onDelete: Cascade)
  zones           Zones                 @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  spawnConditions SpawnConditions[]
  contents        ObjectResetContents[] // Objects that spawn inside this container
}

// ObjectResetContents: Objects that spawn inside a container (nested arbitrarily deep)
model ObjectResetContents {
  id              Int     @id @default(autoincrement())
  resetId         Int     @map("reset_id")
  parentContentId Int?    @map("parent_content_id") // NULL = direct child of reset's object
  objectZoneId    Int     @map("object_zone_id")
  objectId        Int     @map("object_id")
  quantity        Int     @default(1)
  comment         String?

  reset         ObjectResets          @relation(fields: [resetId], references: [id], onDelete: Cascade)
  parentContent ObjectResetContents?  @relation("contentNesting", fields: [parentContentId], references: [id], onDelete: Cascade)
  childContents ObjectResetContents[] @relation("contentNesting")
  objects       Objects               @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
}

model Objects {
  id                      Int
  type                    ObjectType @default(NOTHING)
  keywords                String[]
  name                    String     @map("name")
  plainName               String     @default("") @map("plain_name")
  baseName                String     @default("") @map("base_name") // Name without article (with colors)
  plainBaseName           String     @default("") @map("plain_base_name") // Name without article (plain text)
  article                 String?    @map("article") // null=a/an, "the", "some", ""=none
  roomDescription         String     @map("room_description")
  plainRoomDescription    String     @default("") @map("plain_room_description")
  examineDescription      String?    @map("examine_description")
  plainExamineDescription String?    @default("") @map("plain_examine_description")
  actionDescription       String?    @map("action_desc")
  plainActionDescription  String?    @default("") @map("plain_action_desc")
  weight                  Float      @default(0.0)
  cost                    Int        @default(0)
  timer                   Int        @default(0)
  decomposeTimer          Int        @default(0) @map("decompose_timer")
  level                   Int        @default(1)
  concealment             Int        @default(0)
  values                  Json       @default("{}")
  zoneId                  Int        @map("zone_id")

  // Permanent fixture: If set, this object always exists in this room (no reset needed)
  // Use for fountains, signs, furniture, etc. that never move or despawn
  fixtureRoomZoneId Int?  @map("fixture_room_zone_id")
  fixtureRoomId     Int?  @map("fixture_room_id")
  fixtureRoom       Room? @relation("roomFixtures", fields: [fixtureRoomZoneId, fixtureRoomId], references: [zoneId, id])

  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")
  deletedAt   DateTime?    @map("deleted_at")
  createdBy   String?      @map("created_by")
  updatedBy   String?      @map("updated_by")
  flags        ObjectFlag[]
  restrictions ObjectRestriction[] @default([]) // Behavioral restrictions (NO_DROP, NO_SELL, etc.)
  wearFlags    WearFlag[]

  // FLAG REORGANIZATION FIELDS (NEW)
  // Equipment restrictions (replaces ANTI_* flags)
  // Exclusive restrictions: these races/classes/alignments CANNOT use the item
  restrictedClassIds   Int[]       @default([]) @map("restricted_class_ids") // Class IDs that CANNOT use
  restrictedAlignments Alignment[] @default([]) @map("restricted_alignments") // Alignments that CANNOT use
  restrictedRaces      Race[]      @default([]) @map("restricted_races") // Races that CANNOT use
  // Inclusive restrictions: ONLY these races can use the item (e.g., ELVEN sword)
  // If empty, all races can use (subject to restrictedRaces)
  allowedRaces         Race[]      @default([]) @map("allowed_races") // Only these races CAN use
  minSize              Size?       @map("min_size") // Minimum size to use
  maxSize              Size?       @map("max_size") // Maximum size to use

  // Vehicle properties
  passengerCapacity Int? @map("passenger_capacity") // For VEHICLE items - number of riders

  // Position system: If this item grants/affects position, override presence message
  // e.g., flying carpet: "{actor} soars through the air on a flying carpet."
  presenceOverride String? @map("presence_override")

  characterItems          CharacterItems[]
  equipmentSetItems       EquipmentSetItems[]
  mobCarrying             MobCarrying[]
  mobResetEquipment       MobResetEquipment[]
  objectAffects           ObjectAffects[]
  objectExtraDescriptions ObjectExtraDescriptions[]
  objectResets            ObjectResets[]
  objectResetContents     ObjectResetContents[]
  objectResistances       ObjectResistance[] // Resistance bonuses granted by this item
  grantedEffects          ObjectEffects[]    // Effects granted when worn/held
  zones                   Zones                     @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  shopItems               ShopItems[]
  objectTriggers          ObjectTriggers[] // Trigger attachments via junction table
  objectAbilities         ObjectAbilities[] // Cast spells (quaff potion → cast spell)
  consumableEffects       ConsumableEffect[] // Direct effects (eat food → apply effect)
  accountItems            AccountItems[]
  mailAttachments         PlayerMail[] // Objects attached to mail messages
  // Quest system relations
  questRewards            QuestRewards[]
  objectiveTargetObject   QuestObjectives[]         @relation("objectiveTargetObject")
  questTriggerItem        Quests[]                  @relation("questTriggerItem")
  Triggers                Triggers[]

  @@id([zoneId, id])
  @@index([name])
  @@index([zoneId, name])
  @@index([plainName])
  @@index([plainRoomDescription])
  @@index([plainExamineDescription])
}

model Races {
  race               Race         @id
  name               String // Display name with color codes (XML-Lite format)
  plainName          String       @unique @map("plain_name") // Plain text name - unique identifier
  keywords           String
  playable           Boolean      @default(false)
  humanoid           Boolean      @default(false)
  magical            Boolean      @default(false)
  raceAlign          RaceAlign    @default(GOOD) @map("race_align")
  defaultSize        Size         @default(MEDIUM) @map("default_size")
  defaultAlignment   Int          @default(0) @map("default_alignment")
  bonusDamroll       Int          @default(0) @map("bonus_damroll")
  bonusHitroll       Int          @default(0) @map("bonus_hitroll")
  focusBonus         Int          @default(100) @map("focus_bonus")
  defaultLifeforce   LifeForce    @default(LIFE) @map("default_lifeforce")
  defaultComposition Composition  @default(FLESH) @map("default_composition")
  maleWeightLow      Int          @default(0) @map("male_weight_low")
  maleWeightHigh     Int          @default(0) @map("male_weight_high")
  maleHeightLow      Int          @default(0) @map("male_height_low")
  maleHeightHigh     Int          @default(0) @map("male_height_high")
  femaleWeightLow    Int          @default(0) @map("female_weight_low")
  femaleWeightHigh   Int          @default(0) @map("female_weight_high")
  femaleHeightLow    Int          @default(0) @map("female_height_low")
  femaleHeightHigh   Int          @default(0) @map("female_height_high")
  maxStrength        Int          @default(76) @map("max_strength")
  maxDexterity       Int          @default(76) @map("max_dexterity")
  maxIntelligence    Int          @default(76) @map("max_intelligence")
  maxWisdom          Int          @default(76) @map("max_wisdom")
  maxConstitution    Int          @default(76) @map("max_constitution")
  maxCharisma        Int          @default(76) @map("max_charisma")
  expFactor          Int          @default(100) @map("exp_factor")
  hpFactor           Int          @default(100) @map("hp_factor")
  hitDamageFactor    Int          @default(100) @map("hit_damage_factor")
  damageDiceFactor   Int          @default(100) @map("damage_dice_factor")
  copperFactor       Int          @default(75) @map("copper_factor")
  acFactor           Int          @default(100) @map("ac_factor")
  enterVerb          String?      @map("enter_verb")
  leaveVerb          String?      @map("leave_verb")
  // Elemental resistances: JSON object { "FIRE": 25, "COLD": -25, "HOLY": 100 }
  // Values: -100 (2x damage) to 100 (immune). Stacks multiplicatively.
  resistances Json? @default("{}")

  // Race-specific starting room (e.g., evil races start in their own town)
  // Priority: saveRoom > raceRoom > classRoom > mudDefault
  startRoomZoneId Int? @map("start_room_zone_id")
  startRoomId     Int? @map("start_room_id")

  createdAt            DateTime             @default(now()) @map("created_at")
  updatedAt            DateTime             @updatedAt @map("updated_at")
  permanentEffects     RaceEffects[]        // Effects always active for this race
  raceAbilities        RaceAbilities[]
  raceSpellSlotBonuses RaceSpellSlotBonus[]
}

model RaceAbilities {
  id             Int           @id @default(autoincrement())
  race           Race
  abilityId      Int           @map("ability_id")
  category       SkillCategory @default(SECONDARY)
  bonus          Int           @default(0)
  proficiencyCap Int           @default(100) @map("proficiency_cap") // Max trainable proficiency (0-100)
  raceData       Races         @relation(fields: [race], references: [race], onDelete: Cascade)
  ability        Ability       @relation(fields: [abilityId], references: [id], onDelete: Cascade)

  @@unique([race, abilityId])
}

/// Race-specific bonus spell slots
/// Some races may get extra slots for certain circles (e.g., elves +1 circle 1)
model RaceSpellSlotBonus {
  id     Int  @id @default(autoincrement())
  race   Race
  circle Int // Spell circle (1-14)
  bonus  Int // Bonus slots (+1, +2, etc.)

  raceData Races @relation(fields: [race], references: [race], onDelete: Cascade)

  @@unique([race, circle])
  @@map("RaceSpellSlotBonus")
}

model RoomExit {
  id          Int        @id @default(autoincrement())
  direction   Direction
  description String?
  keywords    String[]   @default([])
  key         String?
  toZoneId    Int?       @map("to_zone_id")
  toRoomId    Int?       @map("to_room_id")
  roomZoneId  Int        @map("room_zone_id")
  roomId      Int        @map("room_id")
  flags       ExitFlag[] @default([])

  // FLAG REORGANIZATION FIELDS (NEW)
  // Replaces CLOSED/LOCKED runtime flags with default state (restored on zone reset)
  defaultState ExitState @default(OPEN) @map("default_state")
  // For bashable doors - hit points before destroyed
  hitPoints    Int?      @map("hit_points")

  sourceRoom      Room  @relation("roomExits", fields: [roomZoneId, roomId], references: [zoneId, id], onDelete: Cascade)
  destinationRoom Room? @relation("roomEntrances", fields: [toZoneId, toRoomId], references: [zoneId, id])

  @@unique([roomZoneId, roomId, direction])
}

model RoomExtraDescriptions {
  id          Int      @id @default(autoincrement())
  keywords    String[]
  description String
  roomZoneId  Int      @map("room_zone_id")
  roomId      Int      @map("room_id")
  rooms       Room     @relation(fields: [roomZoneId, roomId], references: [zoneId, id], onDelete: Cascade)
}

model Room {
  id                   Int
  name                 String
  roomDescription      String     @map("room_description")
  plainRoomDescription String     @default("") @map("plain_room_description")
  sector               Sector     @default(STRUCTURE)
  zoneId               Int        @map("zone_id")
  createdAt            DateTime   @default(now()) @map("created_at")
  updatedAt            DateTime   @updatedAt @map("updated_at")
  deletedAt            DateTime?  @map("deleted_at")
  createdBy            String?    @map("created_by")
  updatedBy            String?    @map("updated_by")

  // Lighting system - base light level determines visibility
  // Positive values = lit, negative = dark, 0 = ambient (time/weather dependent)
  // Examples: 5 = brilliantly lit, -3 = deep darkness, -5 = magical void
  baseLightLevel       Int        @default(0) @map("base_light_level")

  // FLAG REORGANIZATION FIELDS
  // Replaces size flags (LARGE, MEDIUM, etc.) with numeric capacity
  capacity      Int            @default(10) // Max occupants for combat (0 = unlimited)
  // Replaces elemental flags (EARTH, AIR, FIRE, WATER) with magic affinity
  magicAffinity MagicAffinity? @map("magic_affinity")

  // Position/effect system integration
  // What position mechanic is required to be in this room (null = ground OK)
  requiredMechanic     PositionMechanic? @map("required_mechanic")
  // Environmental effects applied to all occupants (e.g., TOXIC_GAS, EXTREME_COLD)
  environmentalEffects RoomEnvironmentalEffect[]

  // Room restrictions - Lua expressions for access control
  // entryRestriction: Lua expression checked when actor tries to enter
  //   Context: actor (who's entering), room (this room), direction (from where)
  //   Returns: true = allow, false = deny, string = deny with message
  //   Examples:
  //     "return actor:is_god()" -- god room
  //     "return actor:is_player()" -- no mobs allowed
  //     "return actor:has_effect('Fly') or actor:has_effect('WaterBreathing')" -- swim/fly required
  entryRestriction String? @map("entry_restriction") @db.Text

  // Common room state flags (for efficient checks without Lua)
  // These can be overridden by entryRestriction for complex logic
  isPeaceful    Boolean @default(false) @map("is_peaceful") // No combat allowed
  allowsMagic   Boolean @default(true) @map("allows_magic") // Magic can be cast
  allowsRecall  Boolean @default(true) @map("allows_recall") // Recall spell works
  allowsSummon  Boolean @default(true) @map("allows_summon") // Summon spell works
  allowsTeleport Boolean @default(true) @map("allows_teleport") // Teleport works
  isDeathTrap   Boolean @default(false) @map("is_death_trap") // Instant death room

  layoutX               Int?                    @map("layout_x")
  layoutY               Int?                    @map("layout_y")
  layoutZ               Int?                    @default(0) @map("layout_z")
  mobResets             MobResets[]
  objectResets          ObjectResets[]
  exits                 RoomExit[]              @relation("roomExits")
  entrances             RoomExit[]              @relation("roomEntrances")
  roomExtraDescriptions RoomExtraDescriptions[]
  zones                 Zones                   @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  fixtures              Objects[]               @relation("roomFixtures") // Permanent objects in this room
  // Quest system relations
  questObjectives       QuestObjectives[]
  questTriggerRoom      Quests[]                @relation("questTriggerRoom")

  @@id([zoneId, id])
  @@index([plainRoomDescription])
}

// Junction table for Room environmental effects (Room has composite PK)
model RoomEnvironmentalEffect {
  roomZoneId Int    @map("room_zone_id")
  roomId     Int    @map("room_id")
  effectId   Int    @map("effect_id")

  room       Room   @relation(fields: [roomZoneId, roomId], references: [zoneId, id], onDelete: Cascade)
  effect     Effect @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@id([roomZoneId, roomId, effectId])
  @@map("RoomEnvironmentalEffect")
}

model ShopAccepts {
  id         Int      @id @default(autoincrement())
  type       String
  keywords   String[]
  shopZoneId Int      @map("shop_zone_id")
  shopId     Int      @map("shop_id")
  shops      Shops    @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)
}

model ShopHours {
  id         Int   @id @default(autoincrement())
  open       Int
  close      Int
  shopZoneId Int   @map("shop_zone_id")
  shopId     Int   @map("shop_id")
  shops      Shops @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)
}

model ShopItems {
  id           Int @id @default(autoincrement())
  amount       Int @default(0)
  price        Int @default(0) @map("price") // Price in copper (0 = use object's base cost)
  shopZoneId   Int @map("shop_zone_id")
  shopId       Int @map("shop_id")
  objectZoneId Int @map("object_zone_id")
  objectId     Int @map("object_id")

  // Spawn and availability controls
  spawnChance           Float   @default(1.0) @map("spawn_chance") // 0.0-1.0 probability
  visibilityRequirement String? @map("visibility_requirement") // Lua expr: when shown in list
  purchaseRequirement   String? @map("purchase_requirement") // Lua expr: when can buy

  objects Objects @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  shops   Shops   @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)

  @@unique([shopZoneId, shopId, objectZoneId, objectId])
}

// Mobs for sale at pet/mount shops (replaces legacy "backroom" hack)
model ShopMobs {
  id         Int @id @default(autoincrement())
  amount     Int @default(-1) // -1 = unlimited stock
  price      Int @default(0) @map("price") // Price in copper (0 = use mob level * 100)
  shopZoneId Int @map("shop_zone_id")
  shopId     Int @map("shop_id")
  mobZoneId  Int @map("mob_zone_id")
  mobId      Int @map("mob_id")

  // Spawn and availability controls
  spawnChance           Float   @default(1.0) @map("spawn_chance") // 0.0-1.0 probability
  visibilityRequirement String? @map("visibility_requirement") // Lua expr: when shown in list
  purchaseRequirement   String? @map("purchase_requirement") // Lua expr: when can buy

  mobs  Mobs  @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  shops Shops @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)

  @@unique([shopZoneId, shopId, mobZoneId, mobId])
}

// Abilities/spells for sale at trainer/healer shops
model ShopAbilities {
  id         Int @id @default(autoincrement())
  price      Int @default(0) @map("price") // Price in copper (0 = use ability circle * 1000)
  shopZoneId Int @map("shop_zone_id")
  shopId     Int @map("shop_id")
  abilityId  Int @map("ability_id")

  // Spawn and availability controls
  spawnChance           Float   @default(1.0) @map("spawn_chance") // 0.0-1.0 probability
  visibilityRequirement String? @map("visibility_requirement") // Lua expr: when shown in list
  purchaseRequirement   String? @map("purchase_requirement") // Lua expr: when can buy

  ability Ability @relation(fields: [abilityId], references: [id], onDelete: Cascade)
  shops   Shops   @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)

  @@unique([shopZoneId, shopId, abilityId])
}

model ShopRooms {
  id         Int   @id @default(autoincrement())
  roomId     Int   @map("room_id")
  shopZoneId Int   @map("shop_zone_id")
  shopId     Int   @map("shop_id")
  shops      Shops @relation(fields: [shopZoneId, shopId], references: [zoneId, id], onDelete: Cascade)

  @@unique([shopZoneId, shopId, roomId])
}

model Shops {
  id                  Int
  buyProfit           Float            @default(1.0) @map("buy_profit")
  sellProfit          Float            @default(1.0) @map("sell_profit")
  temper              Int              @default(0)
  noSuchItemMessages  String[]         @default([]) @map("no_such_item_messages")
  doNotBuyMessages    String[]         @default([]) @map("do_not_buy_messages")
  missingCashMessages String[]         @default([]) @map("missing_cash_messages")
  buyMessages         String[]         @default([]) @map("buy_messages")
  sellMessages        String[]         @default([]) @map("sell_messages")
  keeperZoneId        Int?             @map("keeper_zone_id")
  keeperId            Int?             @map("keeper_id")
  zoneId              Int              @map("zone_id")
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")
  createdBy           String?          @map("created_by")
  updatedBy           String?          @map("updated_by")
  flags               ShopFlag[]
  tradesWithFlags     ShopTradesWith[]
  shopAccepts         ShopAccepts[]
  shopHours           ShopHours[]
  shopItems           ShopItems[]
  shopMobs            ShopMobs[]
  shopRooms           ShopRooms[]
  shopAbilities       ShopAbilities[]
  mobs                Mobs?            @relation(fields: [keeperZoneId, keeperId], references: [zoneId, id])
  zones               Zones            @relation(fields: [zoneId], references: [id], onDelete: Cascade)

  @@id([zoneId, id])
}

model SpawnConditions {
  id            Int           @id @default(autoincrement())
  type          String
  parameters    Json          @default("{}")
  mobResetId    Int?          @map("mob_reset_id")
  objectResetId Int?          @map("object_reset_id")
  mobResets     MobResets?    @relation(fields: [mobResetId], references: [id], onDelete: Cascade)
  objectResets  ObjectResets? @relation(fields: [objectResetId], references: [id], onDelete: Cascade)
}

model Triggers {
  zoneId       Int           @map("zone_id")
  id           Int
  name         String
  attachType   ScriptType
  numArgs      Int           @default(0) @map("num_args")
  argList      String[]      @default([]) @map("arg_list")
  commands     String
  mobZoneId    Int?          @map("mob_zone_id")
  mobId        Int?          @map("mob_id")
  objectZoneId Int?          @map("object_zone_id")
  objectId     Int?          @map("object_id")
  variables    Json          @default("{}")
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  createdBy    String?       @map("created_by")
  updatedBy    String?       @map("updated_by")
  flags        TriggerFlag[]

  // Validation tracking
  needsReview Boolean @default(false) @map("needs_review")
  syntaxError String? @map("syntax_error")

  // Direct FK relations (for triggers attached to a single entity)
  mobs    Mobs?    @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  objects Objects? @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  zones   Zones    @relation(fields: [zoneId], references: [id], onDelete: Cascade)

  // Many-to-many junction tables (for shared triggers)
  mobTriggers    MobTriggers[]
  objectTriggers ObjectTriggers[]

  // Error logging for debugging
  errorLogs ScriptErrorLog[]

  @@id([zoneId, id])
}

/// Junction table for Mob-Trigger many-to-many relationship
/// In DG Scripts, triggers are shared - a single trigger can be attached to multiple mobs
/// via "T <trigger_vnum>" lines in mob files
model MobTriggers {
  mobZoneId     Int      @map("mob_zone_id")
  mobId         Int      @map("mob_id")
  triggerZoneId Int      @map("trigger_zone_id")
  triggerId     Int      @map("trigger_id")
  createdAt     DateTime @default(now()) @map("created_at")

  mob     Mobs     @relation(fields: [mobZoneId, mobId], references: [zoneId, id], onDelete: Cascade)
  trigger Triggers @relation(fields: [triggerZoneId, triggerId], references: [zoneId, id], onDelete: Cascade)

  @@id([mobZoneId, mobId, triggerZoneId, triggerId])
  @@index([triggerZoneId, triggerId])
}

/// Junction table for Object-Trigger many-to-many relationship
model ObjectTriggers {
  objectZoneId  Int      @map("object_zone_id")
  objectId      Int      @map("object_id")
  triggerZoneId Int      @map("trigger_zone_id")
  triggerId     Int      @map("trigger_id")
  createdAt     DateTime @default(now()) @map("created_at")

  object  Objects  @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  trigger Triggers @relation(fields: [triggerZoneId, triggerId], references: [zoneId, id], onDelete: Cascade)

  @@id([objectZoneId, objectId, triggerZoneId, triggerId])
  @@index([triggerZoneId, triggerId])
}

/// Script error log for tracking trigger execution failures over time
/// Used by the scripterrors command to review and debug failed scripts
model ScriptErrorLog {
  id             Int      @id @default(autoincrement())
  triggerZoneId  Int      @map("trigger_zone_id")
  triggerId      Int      @map("trigger_id")
  errorType      String   @map("error_type") // "compilation", "runtime", "timeout"
  errorMessage   String   @map("error_message") @db.Text
  scriptLine     Int?     @map("script_line")
  contextInfo    Json?    @map("context_info") // Entity info, variables, etc.
  occurredAt     DateTime @default(now()) @map("occurred_at")

  trigger Triggers @relation(fields: [triggerZoneId, triggerId], references: [zoneId, id], onDelete: Cascade)

  @@index([triggerZoneId, triggerId])
  @@index([occurredAt])
  @@map("script_error_log")
}

model Users {
  id                  String         @id
  email               String         @unique
  username            String         @unique
  passwordHash        String         @map("password_hash")
  role                UserRole       @default(PLAYER)
  createdAt           DateTime       @default(now()) @map("created_at")
  updatedAt           DateTime       @updatedAt @map("updated_at")
  lastLoginAt         DateTime?      @map("last_login_at")
  resetToken          String?        @map("reset_token")
  resetTokenExpiry    DateTime?      @map("reset_token_expiry")
  failedLoginAttempts Int            @default(0) @map("failed_login_attempts")
  lockedUntil         DateTime?      @map("locked_until")
  lastFailedLogin     DateTime?      @map("last_failed_login")
  preferences         Json?          @default("{}")
  accountWealth       BigInt         @default(0) @map("account_wealth") // Shared account bank in copper
  auditLogs           AuditLogs[]
  banRecordsIssued    BanRecords[]   @relation("bannedByUser")
  banRecords          BanRecords[]   @relation("userBanRecords")
  changeLogs          ChangeLogs[]
  characters          Characters[]
  grants              UserGrants[]
  grantsIssued        UserGrants[]   @relation("grantsIssued")
  accountItems        AccountItems[]
  accountMailSent     AccountMail[]  @relation("accountMailSent")
  accountMailReceived AccountMail[]  @relation("accountMailReceived")
  discordLink         DiscordLink?
  // Soft delete support
  deletedAt           DateTime?      @map("deleted_at")
  deletionReason      String?        @map("deletion_reason")
}

model UserGrants {
  id           Int               @id @default(autoincrement())
  userId       String            @map("user_id")
  resourceType GrantResourceType @map("resource_type")
  resourceId   String            @map("resource_id")
  permissions  GrantPermission[]
  grantedBy    String            @map("granted_by")
  grantedAt    DateTime          @default(now()) @map("granted_at")
  expiresAt    DateTime?         @map("expires_at")
  notes        String?

  user          Users @relation(fields: [userId], references: [id], onDelete: Cascade)
  grantedByUser Users @relation("grantsIssued", fields: [grantedBy], references: [id])

  @@unique([userId, resourceType, resourceId])
  @@map("user_grants")
}

// Account-wide item storage (accessible by all characters on the account)
// Requires character to be linked to a user account
model AccountItems {
  id                  Int      @id @default(autoincrement())
  userId              String   @map("user_id")
  slot                Int      @default(0) // Position in storage for ordering
  objectZoneId        Int      @map("object_zone_id")
  objectId            Int      @map("object_id")
  quantity            Int      @default(1) // For stackable items
  customData          Json?    @map("custom_data") // Item modifications (enchants, etc)
  storedAt            DateTime @default(now()) @map("stored_at")
  storedByCharacterId String?  @map("stored_by_character_id") // Which character deposited it

  user      Users       @relation(fields: [userId], references: [id], onDelete: Cascade)
  object    Objects     @relation(fields: [objectZoneId, objectId], references: [zoneId, id])
  character Characters? @relation(fields: [storedByCharacterId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@map("account_items")
}

// Global events for seasonal content, promotions, and special occasions
model Events {
  id          Int     @id @default(autoincrement())
  name        String  @unique // e.g., "christmas", "halloween", "summer_festival"
  displayName String  @map("display_name") // e.g., "Christmas Event"
  description String?

  // Scheduling (null = manual activation only)
  startDate DateTime? @map("start_date")
  endDate   DateTime? @map("end_date")
  recurring Boolean   @default(false) // repeats yearly?

  // Manual override
  active Boolean @default(false) // manual on/off toggle

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by")
  updatedBy String?  @map("updated_by")

  // Quest system relations
  questTriggerEvent Quests[] @relation("questTriggerEvent")
}

model Zones {
  id           Int            @id
  name         String
  lifespan     Int            @default(30)
  resetMode    ResetMode      @default(NORMAL)
  hemisphere   Hemisphere     @default(NORTHWEST)
  climate      Climate        @default(NONE)
  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @updatedAt @map("updated_at")
  deletedAt    DateTime?      @map("deleted_at")
  createdBy    String?        @map("created_by")
  updatedBy    String?        @map("updated_by")
  mobResets    MobResets[]
  mobs         Mobs[]
  objectResets ObjectResets[]
  objects      Objects[]
  rooms        Room[]
  shops        Shops[]
  triggers     Triggers[]
  // Quest system
  quests       Quests[]
}

// ============================================================================
// SOCIALS (Emotes/Actions)
// ============================================================================

model Social {
  id                Int      @id @default(autoincrement())
  name              String   @unique // Command name (e.g., "smile", "bow", "hug")
  hide              Boolean  @default(false) // Hide who initiated the action
  minVictimPosition Position @default(STANDING) @map("min_victim_position") // Victim must be at least this position

  // No argument provided - actor alone
  charNoArg   String? @map("char_no_arg") // Message to actor
  othersNoArg String? @map("others_no_arg") // Message to room

  // Argument provided, target found
  charFound   String? @map("char_found") // Message to actor (null = no target allowed)
  othersFound String? @map("others_found") // Message to room (excluding target)
  victFound   String? @map("vict_found") // Message to target

  // Argument provided, target not found
  notFound String? @map("not_found") // "Can't find that person"

  // Self-targeting (actor targets themselves)
  charAuto   String? @map("char_auto") // Message to actor
  othersAuto String? @map("others_auto") // Message to room

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([name])
}

// ============================================================================
// ENUMS
// ============================================================================

enum ReportType {
  BUG
  IDEA
  TYPO
}

enum ReportStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  WONT_FIX
  DUPLICATE
}

enum Climate {
  NONE
  SEMIARID
  ARID
  OCEANIC
  TEMPERATE
  SUBTROPICAL
  TROPICAL
  SUBARCTIC
  ARCTIC
  ALPINE
}

enum Composition {
  FLESH
  EARTH
  AIR
  FIRE
  WATER
  ICE
  MIST
  ETHER
  METAL
  STONE
  BONE
  LAVA
  PLANT
}

enum DamageType {
  HIT
  STING
  WHIP
  SLASH
  BITE
  BLUDGEON
  CRUSH
  POUND
  CLAW
  MAUL
  THRASH
  PIERCE
  BLAST
  PUNCH
  STAB
  FIRE
  COLD
  ACID
  SHOCK
  POISON
  ALIGN
  MENTAL
  ROT
  ENERGY
  WATER
}

enum Direction {
  NORTH
  EAST
  SOUTH
  WEST
  UP
  DOWN
  NORTHEAST
  NORTHWEST
  SOUTHEAST
  SOUTHWEST
  IN
  OUT
  PORTAL
  NONE
}

// EffectFlag enum REMOVED
// Effects are defined in the Effect table and linked via junction tables:
// - MobDefaultEffects: Effects mobs always spawn with
// - ObjectEffects: Effects objects grant when worn/held
// - CharacterEffects: Runtime effects on player characters
// This allows builders to create custom effects without schema changes

enum ExitFlag {
  IS_DOOR // Has a door (enables open/close/lock/pick)
  PICKPROOF // Cannot be picked with lockpicks
  HIDDEN // Exit not visible until searched
  BASHABLE // Can be broken down with bash skill
  MAGICPROOF // Immune to knock spell and dispel magic
}

enum Gender {
  NEUTRAL
  MALE
  FEMALE
  NON_BINARY
}

enum MobRole {
  TRASH
  NORMAL
  ELITE
  MINIBOSS
  BOSS
  RAID_BOSS
}

// ============================================================================
// FLAG REORGANIZATION ENUMS (NEW)
// ============================================================================

// Identity properties - what the mob IS
enum MobTrait {
  ILLUSION // Mob is an illusion, can be dispelled
  ANIMATED // Mob is animated (skeleton, golem), dies if animation removed
  PLAYER_PHANTASM // Illusion of a player; other mobs are aggressive toward it
  AQUATIC // Can only exist in water sector rooms
  MOUNT // Can be ridden as a mount
  SUMMONED // Was magically summoned, can be banished
  PET // Was purchased or tamed, follows owner
}

// Behavioral patterns - how the mob ACTS
enum MobBehavior {
  // Movement
  SENTINEL // Won't wander from spawn room
  STAY_ZONE // Won't leave its home zone
  SCAVENGER // Picks up items from ground
  // Tracking
  TRACK // Will track enemies who flee
  SLOW_TRACK // Tracks but with delays
  FAST_TRACK // Tracks quickly and persistently
  // Combat stance
  WIMPY // Flees when health is low
  AWARE // Cannot be backstabbed or pickpocketed
  HELPER // Assists other mobs in combat
  PROTECTOR // Protects specific NPCs when attacked
  PEACEKEEPER // Attacks anyone who initiates combat
  // Combat restrictions
  NO_BASH // Cannot be bashed/knocked down
  NO_SUMMON // Cannot be summoned
  NO_VICIOUS // Ignores vicious stance damage bonus
  // Social
  MEMORY // Remembers attackers, hostile on return
  TEACHER // Can teach skills to players
  MEDITATE // Meditates to recover (spell memorization)
  // Special
  NO_SCRIPT // Doesn't run Lua triggers
  NO_CLASS_AI // Doesn't use class-based AI behaviors
  // Combat behavior
  PEACEFUL // Cannot be attacked
  NO_KILL // Fights but won't deliver killing blow
}

// Room magic affinity - affects spell power and creature comfort
enum MagicAffinity {
  // Elemental
  FIRE // Fire spells +%, cold -%, fire elementals comfortable
  WATER // Water spells +%, aquatic creatures thrive
  COLD // Cold/ice spells +%, fire -%, frozen terrain
  EARTH // Earth spells +%, stone creatures empowered
  AIR // Air/lightning spells +%, flying creatures benefit
  // Divine/Planar
  HOLY // Holy spells +%, unholy -%, undead weakened
  UNHOLY // Unholy spells +%, holy -%, undead empowered
  SHADOW // Shadow spells +%, radiant -%, darkness persists
  DEATH // Necromancy +%, not evil - just close to death
  ASTRAL // Summoning/teleport +%, planar barriers weak
  // Other
  NATURE // Nature/druid spells +%, fey welcome
  ARCANE // All magic +% or spell regen bonus
  CHAOS // Wild magic - unpredictable side effects
}

// Mob profession - special NPC roles that provide services
// A mob can have multiple professions (e.g., banker + receptionist)
enum MobProfession {
  BANKER // Manages player bank accounts
  SHOPKEEPER // Runs shops (buy/sell items)
  RECEPTIONIST // Manages lodging/inn services
  POSTMASTER // Handles mail system
  GUILDMASTER // Manages guild services
  TRAINER // Trains skills/abilities
}

// Exit default state - restored on zone reset
enum ExitState {
  OPEN // Door open or no door
  CLOSED // Door closed but unlocked
  LOCKED // Door closed and locked
}

enum Hemisphere {
  NORTHWEST
  NORTHEAST
  SOUTHWEST
  SOUTHEAST
}

enum LifeForce {
  LIFE
  UNDEAD
  MAGIC
  CELESTIAL
  DEMONIC
  ELEMENTAL
}

// MobFlag enum REMOVED - all functionality now handled by:
// - MobTrait[] for identity (what mob IS)
// - MobBehavior[] for behavior (how mob ACTS)
// - MobProfession[] for services (what mob DOES for players)
// - classId for class-based AI
// - aggressionFormula for aggro targeting (Lua)
// - activityRestrictions for environmental restrictions (Lua)
// - effectFlags for buffs/debuffs (effects system)
// - resistances for immunities (JSON field)

// Object intrinsic properties - what the object IS
enum ObjectFlag {
  GLOW // Object emits light.  Can be found in dark rooms, but doesn't light area
  HUM // Object hums audibly.  Can be found if blind or invisible
  INVISIBLE // Object is invisible by default
  MAGIC // Object is magical (affects identify, dispel)
  PERMANENT // Object doesn't decay
  TEMPORARY // Object vanishes on rent/logout
  DECOMPOSING // Object is actively decaying
  FLOAT // Doesn't fall in air/gravity rooms
  BUOYANT // Floats in water (boats)
  VEHICLE // Can carry passengers
  SOULBOUND // Persists through death, cannot trade/drop
}

// Object behavioral restrictions - what CAN'T be done with the object
enum ObjectRestriction {
  NO_DROP // Cannot be dropped
  NO_TAKE // Cannot be picked up (fixture)
  NO_SELL // Cannot be sold to shops
  NO_BURN // Immune to fire damage
  NO_LOCATE // Cannot be found with locate spell
  NO_INVISIBLE // Cannot be made invisible by spells
}

enum ObjectType {
  // Core item types
  NOTHING
  LIGHT
  SCROLL
  WAND
  STAFF
  WEAPON
  FIREWEAPON
  MISSILE
  TREASURE
  ARMOR
  POTION
  WORN
  OTHER
  TRASH
  TRAP
  CONTAINER
  NOTE
  DRINKCONTAINER
  KEY
  FOOD
  MONEY
  PEN
  BOAT
  FOUNTAIN
  PORTAL
  ROPE
  SPELLBOOK
  WALL
  TOUCHSTONE
  BOARD
  INSTRUMENT
  // Additional game-specific types
  VEHICLE     // Rideable vehicles
  CORPSE      // Character remains
  KIT         // Tool kits (crafting, etc.)
  WINGS       // Flight-granting items
  PERFUME     // Scent items
  DISGUISE    // Appearance modifiers
  POISON      // Poison items
}

// Body position - physical state of an actor
// Separate from movement mode (flying, swimming, etc.)
enum Position {
  // Incapacitation states
  DEAD // Killed - awaiting respawn
  GHOST // Player post-death state - can use 'release'
  MORTALLY_WOUNDED // Critical HP - dying
  INCAPACITATED // Knocked out
  STUNNED // Temporarily unable to act
  // Rest states
  SLEEPING // Asleep - fast regen, vulnerable
  RESTING // Lying down or prone - moderate regen
  // Seated states
  SITTING // Seated - some actions restricted
  // Active states
  STANDING // Default upright position
}

// Movement mode - how an actor is traveling
// Can combine with any body position (e.g., sleeping while flying on carpet)
enum MovementMode {
  NORMAL // Walking/running on ground
  FLYING // Airborne - aerial combat rules
  SWIMMING // On water surface
  UNDERWATER // Submerged - breathing required
  MOUNTED // Riding a mount
  ETHEREAL // Phased/incorporeal
}

// Position mechanics - C++ has hardcoded game rules for each mechanic
// Positions/modes map to mechanics for gameplay rules
enum PositionMechanic {
  GROUND // Normal ground-based (standing, sitting, resting)
  AERIAL // Flying/hovering - aerial combat rules, immune to ground effects
  AQUATIC // Swimming on surface - water combat rules
  SUBMERGED // Underwater - breathing checks, spell restrictions
  ETHEREAL // Phasing/incorporeal - pass through certain terrain
  MOUNTED // Riding a mount - mount-based combat rules
  INCAPACITATED // Dead, stunned, unconscious - can't act
}

// Race enum - species/creature types
enum Race {
  // Playable races
  HUMAN
  ELF
  GNOME
  DWARF
  DROW
  DUERGAR
  HALF_ELF
  HALFLING
  SVERFNEBLIN
  GOLIATH
  // Fey races
  BROWNIE
  FAERIE_SEELIE
  FAERIE_UNSEELIE
  NYMPH
  ARBOREAN
  // Monstrous races
  TROLL
  OGRE
  ORC
  GOBLIN
  GIANT
  DEMON
  // Dragon types
  DRAGON_GENERAL
  DRAGON_FIRE
  DRAGON_FROST
  DRAGON_ACID
  DRAGON_LIGHTNING
  DRAGON_GAS
  // Dragonborn
  DRAGONBORN_FIRE
  DRAGONBORN_FROST
  DRAGONBORN_ACID
  DRAGONBORN_LIGHTNING
  DRAGONBORN_GAS
  // Generic categories
  HUMANOID // Default for unspecified humanoids
  ANIMAL
  PLANT
  OTHER
}

enum RaceAlign {
  UNKNOWN
  GOOD
  EVIL
}

// Alignment for item restrictions
enum Alignment {
  GOOD
  NEUTRAL
  EVIL
}

enum ResetMode {
  NEVER
  EMPTY
  NORMAL
}

// RoomFlag enum REMOVED - replaced by:
// - baseLightLevel field for lighting (numeric, more flexible)
// - Lua room restrictions for access control (godroom, no_mob, no_magic, etc.)
// - Sector type for environment (indoors, underwater, underground, etc.)
// - capacity field for occupancy limits
// - Mob presence for features (shop, bank, inn, temple)

enum SaveResult {
  NONE
  HALF
  NEGATE
  REDUCE25
  CUSTOM
}

enum SaveType {
  // Modern D&D 3.x/5e style saves
  REFLEX // Dodge/avoid effects (DEX-based) - replaces legacy BREATH
  FORTITUDE // Resist physical effects (CON-based) - replaces legacy POISON, PARALYSIS, PETRIFICATION
  WILL // Resist mental effects (WIS-based) - replaces legacy SPELL, ROD, WAND
}

enum ApplyType {
  AC
  HITROLL
  DAMROLL
  STR
  DEX
  INT
  WIS
  CON
  CHA
  SAVING_PARA
  SAVING_ROD
  SAVING_PETRI
  SAVING_BREATH
  SAVING_SPELL
  HIT_REGEN
  MAX_HP
  MAX_MANA
  MAX_MOVEMENT
  PERCEPTION
  HIDDENNESS
  SIZE
  AGE
  CHAR_WEIGHT
  CHAR_HEIGHT
  FOCUS
  COMPOSITION
  LEVEL
  NONE
}

enum ScriptType {
  MOB
  OBJECT
  WORLD
}

enum Sector {
  STRUCTURE
  CITY
  FIELD
  FOREST
  HILLS
  MOUNTAIN
  SHALLOWS
  WATER
  UNDERWATER
  AIR
  ROAD
  GRASSLANDS
  CAVE
  RUINS
  SWAMP
  BEACH
  UNDERDARK
  ASTRALPLANE
  AIRPLANE
  FIREPLANE
  EARTHPLANE
  ETHEREALPLANE
  AVERNUS
}

enum ShopFlag {
  WILL_FIGHT
  USES_BANK
  WILL_BANK_MONEY
  WILL_START_FIGHT
}

enum ShopTradesWith {
  ALIGNMENT
  RACE
  CLASS
  TRADE_NOGOOD
  TRADE_NOEVIL
  TRADE_NONEUTRAL
  TRADE_NOCLERIC
  TRADE_NOTHIEF
  TRADE_NOWARRIOR
}

enum Size {
  TINY
  SMALL
  MEDIUM
  LARGE
  HUGE
  GIANT
  GARGANTUAN
  COLOSSAL
  TITANIC
  MOUNTAINOUS
}

enum SkillCategory {
  PRIMARY
  SECONDARY
  RESTRICTED
  FORBIDDEN
}

enum SkillType {
  WEAPON
  COMBAT
  MAGIC
  STEALTH
  SOCIAL
  CRAFTING
  SURVIVAL
  KNOWLEDGE
  UTILITY
}

enum StackingRule {
  REFRESH
  STACK
  IGNORE
  MAX_ONLY
}

enum Stance {
  DEAD
  MORT
  INCAPACITATED
  STUNNED
  SLEEPING
  RESTING
  ALERT
  FIGHTING
}

enum TargetScope {
  SINGLE
  ROOM
  GROUP
  AREA
  CHAIN
  CONE
  LINE
  SELF
}

enum TargetType {
  SELF
  ALLY_PC
  ALLY_NPC
  ALLY_GROUP
  ENEMY_PC
  ENEMY_NPC
  OBJECT_INV
  OBJECT_WORLD
  CORPSE
  RIDER // Target rider on a mount (for Buck skill)
  UNCONSCIOUS // Target unconscious entities (for Drag skill)
}

enum SpellSphere {
  GENERIC
  FIRE
  WATER
  EARTH
  AIR
  HEALING
  PROTECTION
  ENCHANTMENT
  SUMMONING
  DEATH
  DIVINATION
}

enum ElementType {
  // Physical damage types
  PHYSICAL // Generic weapon damage (fallback)
  SLASH // Slashing weapons (swords, axes)
  PIERCE // Piercing weapons (daggers, spears, arrows)
  CRUSH // Crushing weapons (maces, hammers, fists)
  FORCE // Magical kinetic energy, hits ethereal
  SONIC // Sound/thunder, ignores physical armor
  BLEED // Physical DoT, bypasses some armor

  // Classical elements
  FIRE // Heat, burning (opposes COLD)
  COLD // Freezing, slowing (opposes FIRE)
  WATER // Drowning, pressure, conducts SHOCK
  EARTH // Crushing, grounding (opposes AIR)
  AIR // Suffocation, cutting winds (opposes EARTH)
  SHOCK // Electricity, chains in water
  ACID // Corrosion, DoT
  POISON // Toxins, CON-based resist

  // Light/Dark
  RADIANT // Pure light energy (opposes SHADOW)
  SHADOW // Darkness/void (opposes RADIANT)

  // Divine
  HOLY // Divine positive (opposes UNHOLY)
  UNHOLY // Divine negative (opposes HOLY)

  // Life/Death
  HEAL // Restoration, inverts on undead (opposes NECROTIC)
  NECROTIC // Life drain, withering (opposes HEAL)

  // Other
  MENTAL // Psychic/psionic, ignores armor
  NATURE // Druidic/primal energy
}

enum TriggerFlag {
  // Common flags (all types)
  GLOBAL
  RANDOM
  COMMAND
  LOAD
  CAST
  LEAVE
  TIME

  // MOB-specific flags
  SPEECH
  ACT
  DEATH
  GREET
  GREET_ALL
  ENTRY
  RECEIVE
  FIGHT
  HIT_PERCENT
  BRIBE
  MEMORY
  DOOR
  SPEECH_TO
  LOOK
  AUTO // Legacy, may be unused

  // OBJECT-specific flags
  ATTACK // Weapon triggers on attack
  DEFEND // Weapon triggers on defense
  TIMER // Item timer expires
  GET // Item picked up
  DROP // Character tries to drop
  GIVE // Character tries to give
  WEAR // Character tries to wear
  REMOVE // Character tries to remove
  USE // Object is used
  CONSUME // Character eats/drinks object

  // WORLD-specific flags
  RESET // Zone has been reset
  PREENTRY // Someone about to enter room
  POSTENTRY // Someone just entered room
}

enum UserRole {
  PLAYER
  IMMORTAL
  BUILDER
  HEAD_BUILDER
  CODER
  GOD
}

enum GrantResourceType {
  ZONE
  MOB
  OBJECT
  SHOP
}

enum GrantPermission {
  READ
  WRITE
  DELETE
  ADMIN
}

// Wear flags - equipment slots where an item can be worn
// Note: TAKE was removed - use ObjectRestriction.NO_TAKE instead
enum WearFlag {
  // Jewelry
  FINGER // Rings
  NECK // Necklaces, amulets
  EAR // Earrings
  WRIST // Bracelets, bracers
  // Head/Face
  HEAD // Helmets, hats, crowns
  EYES // Goggles, glasses
  FACE // Masks, veils
  // Body
  BODY // Armor, robes, shirts
  ABOUT // Cloaks, capes
  ARMS // Arm guards, sleeves
  HANDS // Gloves, gauntlets
  WAIST // Belts, sashes, girdles
  BELT // Items hanging from belt (requires WAIST)
  // Lower body
  LEGS // Pants, greaves
  FEET // Boots, shoes
  TAIL // Tail decorations (for tailed races)
  // Weapons/Held
  MAINHAND // Primary weapon/tool
  OFFHAND // Shield, offhand weapon, torch, held item
  TWOHAND // Requires both hands (versatile weapons have MAINHAND + TWOHAND)
  // Special
  BADGE // Badges, insignia
  HOVER // Hovering items (ioun stones, familiars)
  DISGUISE // Disguise/transformation slot
}

// Player preference and state flags (mirrors C++ PlayerFlag enum)
enum PlayerFlag {
  // Display preferences
  BRIEF // Show shortened room descriptions
  COMPACT // Reduce blank lines in output
  NO_REPEAT // Don't echo commands back

  // Auto-actions
  AUTO_LOOT // Automatically loot corpses after kills
  AUTO_GOLD // Automatically take gold from corpses
  AUTO_SPLIT // Automatically split gold with group
  AUTO_EXIT // Automatically show exits
  AUTO_ASSIST // Automatically assist group members

  // Combat preferences
  WIMPY // Flee when HP is low (threshold stored separately)
  SHOW_DICE_ROLLS // Show detailed dice rolls and damage calculations

  // Social/Status
  AFK // Away from keyboard
  DEAF // Ignore shouts and gossip
  NO_TELL // Refuse tells from non-gods
  NO_SUMMON // Refuse summon spells
  QUEST // Currently on a quest

  // PK/Consent
  PK_ENABLED // Player killing enabled
  CONSENT // Consent to dangerous actions from other players

  // Accessibility
  COLOR_BLIND // Use colorblind-friendly colors
  MSP // MUD Sound Protocol enabled
  MXP_ENABLED // MUD eXtension Protocol enabled

  // Immortal preferences
  HOLY_LIGHT // See everything (invisible, dark, hidden, etc.)
  SHOW_IDS // Show entity IDs on mobs/objects/rooms
}

// Permission flags for commands and staff abilities
// Granted by levels and can be individually assigned to characters
enum Permission {
  // Role-based permissions
  BUILD // Can use OLC/builder commands
  CODE // Can use coding/debugging commands
  ADMIN // Can use administrative commands
  GOD // Full god-level access

  // System commands
  SHUTDOWN // Can shut down the MUD
  WIZLOCK // Can lock out mortals
  SYSLOG // Can view system logs
  LOG // Can toggle logging on players

  // Player management
  FORCE // Can force players to execute commands
  SNOOP // Can monitor player sessions
  FREEZE // Can freeze players
  THAW // Can unfreeze players
  BAN // Can ban players/IPs
  UNBAN // Can remove bans
  DC // Can disconnect players
  ADVANCE // Can change player levels
  RESTORE // Can fully restore players
  NOTITLE // Can remove player titles
  SQUELCH // Can squelch players from channels

  // World manipulation
  TELEPORT // Can teleport self/others
  TRANSFER // Can transfer players between rooms
  SUMMON // Can summon players
  INVISIBLE // Can go invisible at will
  NOHASSLE // Immune to mob aggro
  ZONE_RESET // Can manually reset zones

  // Communication
  WIZNET // Can use immortal communication channel
  OLC // Can use online creation system
}

// Per-instance flags for items in player inventory
// These track state specific to one instance of an item
enum ItemInstanceFlag {
  IDENTIFIED // The item has been identified (reveals stats)
  CURSED_KNOWN // The player knows the item is cursed
  ATTUNED // Item is attuned to this character (for attunement items)
  CUSTOM_NAMED // Has a player-given custom name
  CUSTOM_DESCRIBED // Has a player-given custom description
  STOLEN // Item was stolen (some NPCs may refuse to buy)
  QUEST_FLAGGED // Marked as relevant to a quest
  HEIRLOOM // Protected from accidental sale/discard
}

// ============================================================================
// PLAYER MAIL SYSTEM
// ============================================================================

// Stores in-game mail messages between players
// Character-to-character mail (retrieved via in-game postmaster)
model PlayerMail {
  id Int @id @default(autoincrement())

  // Legacy IDs for import (numeric player IDs from CircleMUD)
  // These are used during import and will be remapped to character IDs after character migration
  legacySenderId    Int? @map("legacy_sender_id")
  legacyRecipientId Int? @map("legacy_recipient_id")

  // Character relationships (null = legacy mail not yet linked, or deleted sender)
  senderCharacterId    String? @map("sender_character_id")
  recipientCharacterId String? @map("recipient_character_id")

  // Mail content
  body String @db.Text

  // Timestamps
  sentAt DateTime  @map("sent_at")
  readAt DateTime? @map("read_at")

  // Wealth attachments (stored in individual coin types)
  attachedCopper   Int @default(0) @map("attached_copper")
  attachedSilver   Int @default(0) @map("attached_silver")
  attachedGold     Int @default(0) @map("attached_gold")
  attachedPlatinum Int @default(0) @map("attached_platinum")

  // Object attachment (optional) - uses composite key
  attachedObjectZoneId Int? @map("attached_object_zone_id")
  attachedObjectId     Int? @map("attached_object_id")

  // Retrieval tracking (for postmaster)
  wealthRetrievedAt            DateTime? @map("wealth_retrieved_at")
  wealthRetrievedByCharacterId String?   @map("wealth_retrieved_by_character_id")
  objectRetrievedAt            DateTime? @map("object_retrieved_at")
  objectRetrievedByCharacterId String?   @map("object_retrieved_by_character_id")
  objectMovedToAccountStorage  Boolean   @default(false) @map("object_moved_to_account_storage")

  // Status
  isDeleted Boolean @default(false) @map("is_deleted")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  sender                     Characters? @relation("mailSent", fields: [senderCharacterId], references: [id], onDelete: SetNull)
  recipient                  Characters? @relation("mailReceived", fields: [recipientCharacterId], references: [id], onDelete: Cascade)
  attachedObject             Objects?    @relation(fields: [attachedObjectZoneId, attachedObjectId], references: [zoneId, id], onDelete: SetNull)
  wealthRetrievedByCharacter Characters? @relation("mailWealthRetrievedBy", fields: [wealthRetrievedByCharacterId], references: [id], onDelete: SetNull)
  objectRetrievedByCharacter Characters? @relation("mailObjectRetrievedBy", fields: [objectRetrievedByCharacterId], references: [id], onDelete: SetNull)

  @@index([senderCharacterId])
  @@index([recipientCharacterId])
  @@index([legacySenderId])
  @@index([legacyRecipientId])
  @@index([sentAt])
  @@map("PlayerMail")
}

// Account-to-account mail (viewable by any character on the account)
model AccountMail {
  id Int @id @default(autoincrement())

  // Account relationships
  senderUserId    String  @map("sender_user_id")
  recipientUserId String? @map("recipient_user_id") // null for broadcast

  // Broadcast flag
  isBroadcast Boolean @default(false) @map("is_broadcast")

  // Mail content
  subject String
  body    String @db.Text

  // Timestamps
  sentAt DateTime  @default(now()) @map("sent_at")
  readAt DateTime? @map("read_at")

  // Status
  isDeleted Boolean @default(false) @map("is_deleted")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  sender    Users  @relation("accountMailSent", fields: [senderUserId], references: [id], onDelete: Cascade)
  recipient Users? @relation("accountMailReceived", fields: [recipientUserId], references: [id], onDelete: Cascade)

  @@index([senderUserId])
  @@index([recipientUserId])
  @@index([isBroadcast])
  @@index([sentAt])
  @@map("AccountMail")
}

// ============================================================================
// GAME CONFIGURATION SYSTEM
// ============================================================================

// Server configuration - key/value store with categories
// All game settings loaded from here at startup
model GameConfig {
  id          Int             @id @default(autoincrement())
  category    String // "server", "combat", "progression", "security", "timing", "character", "display"
  key         String // "port", "max_connections", etc.
  value       String // JSON-encoded value
  valueType   ConfigValueType @default(STRING) @map("value_type")
  description String? // Admin help text
  minValue    String?         @map("min_value") // Validation bounds (JSON)
  maxValue    String?         @map("max_value")
  isSecret    Boolean         @default(false) @map("is_secret") // Hide from non-admins
  restartReq  Boolean         @default(false) @map("restart_req") // Requires server restart

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([category, key])
  @@index([category])
  @@map("GameConfig")
}

// Player level definitions - XP requirements, stat gains, immortal status
model LevelDefinition {
  level       Int      @id
  name        String? // Optional name: "Immortal", "Avatar", "God"
  expRequired Int      @default(0) @map("exp_required") // XP to reach this level
  hpGain      Int      @default(10) @map("hp_gain") // HP gained at this level
  staminaGain Int      @default(5) @map("stamina_gain") // Stamina gained at this level
  isImmortal  Boolean      @default(false) @map("is_immortal")
  permissions Permission[] @default([]) // Permission flags granted at this level

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("LevelDefinition")
}

// Command definitions - synced from C++ on startup
// Defines what permissions each command requires
model Command {
  name         String          @id // Primary command name: "shutdown", "goto", "ban"
  aliases      String[]        @default([]) // Alternative names: ["teleport"] for goto
  category     CommandCategory @default(SYSTEM)
  description  String? // Brief help text
  usage        String? // Syntax: "shutdown [delay]"
  immortalOnly Boolean         @default(false) @map("immortal_only") // Requires isImmortal level
  permissions  Permission[]    @default([]) // Required permission flags

  // Optional link to ability for skill/spell/chant/song commands
  // If set, executing this command triggers the linked ability's effects
  abilityId Int?     @map("ability_id")
  ability   Ability? @relation(fields: [abilityId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@index([abilityId])
  @@map("Command")
}

enum CommandCategory {
  MOVEMENT // north, south, goto
  COMBAT // kill, flee, bash
  COMMUNICATION // say, tell, gossip
  OBJECT // get, drop, wear
  INFORMATION // look, score, who
  SOCIAL // smile, nod, wave
  ADMIN // shutdown, ban, force
  BUILDING // redit, oedit, zedit
  SYSTEM // save, quit, password
  CLAN // clan commands
  MAGIC // cast, memorize
  SKILLS // practice, train
}

// System text content (MOTD, screens, messages)
// Core screens loaded by the MUD at runtime
model SystemText {
  id       Int                @id @default(autoincrement())
  key      String             @unique // "motd", "welcome_screen", "imotd", "news", "credits"
  category SystemTextCategory @default(SYSTEM)
  title    String? // Display title
  content  String             @db.Text // Full text content (supports color codes)
  minLevel Int                @default(0) @map("min_level") // Visibility level requirement
  isActive Boolean            @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@map("SystemText")
}

// Player toggle definitions (brief, autoloot, etc.)
// Defines available toggle options - players store their values in character flags
model PlayerToggle {
  id           Int            @id @default(autoincrement())
  name         String         @unique // Internal name: "brief", "autoloot", "autogold"
  displayName  String         @map("display_name") // UI name: "Brief Mode"
  description  String // Help text: "Show brief room descriptions"
  defaultValue Boolean        @default(false) @map("default_value")
  minLevel     Int            @default(0) @map("min_level") // 0 = all, 100+ = immortal
  category     ToggleCategory @default(DISPLAY)
  sortOrder    Int            @default(0) @map("sort_order")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@map("PlayerToggle")
}

enum ToggleCategory {
  DISPLAY // brief, compact, autoexit
  COMBAT // autoloot, autogold, autosplit
  SOCIAL // deaf, notell, afk
  IMMORTAL // holylight, showids, roomflags
}

// Login/character creation messages
// Allows customization of all login flow text
model LoginMessage {
  id       Int        @id @default(autoincrement())
  stage    LoginStage // Enum for type safety
  variant  String     @default("default") // For A/B testing or themes
  message  String     @db.Text
  isActive Boolean    @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([stage, variant])
  @@map("LoginMessage")
}

// ============================================================================
// CONFIGURATION ENUMS
// ============================================================================

enum ConfigValueType {
  STRING
  INT
  FLOAT
  BOOL
  JSON
}

enum SystemTextCategory {
  LOGIN // MOTD, welcome screens
  SYSTEM // Credits, policies, background
  COMBAT // Death messages, victory messages
  IMMORTAL // Immortal-only content
}

enum LoginStage {
  WELCOME_BANNER // Initial connection banner
  USERNAME_PROMPT // "Enter username:"
  PASSWORD_PROMPT // "Password:"
  INVALID_LOGIN // Login failed message
  TOO_MANY_ATTEMPTS // Lockout message
  CHARACTER_SELECT // Character selection prompt
  CREATE_NAME_PROMPT // "Enter character name:"
  CREATE_PASSWORD // "Choose password:"
  CONFIRM_PASSWORD // "Confirm password:"
  SELECT_CLASS // Class selection prompt
  SELECT_RACE // Race selection prompt
  CREATION_COMPLETE // Character created message
  RECONNECT_MESSAGE // Reconnecting to existing session
}

// ============================================================================
// BULLETIN BOARD SYSTEM
// ============================================================================
// Boards are linked to ITEM_BOARD objects via values.value0 = board.id
// Players interact with boards through board objects placed in rooms

model Board {
  id     Int     @id @default(autoincrement())
  alias  String  @unique // Filename without extension: "mortal", "god", "quest"
  title  String // Display title: "Mortal Board", "God Board"
  locked Boolean @default(false) // Moderator lock - blocks all posts/edits

  // Privilege rules for 8 access types (stored as JSON for flexibility)
  // 0=READ, 1=WRITE_NEW, 2=REMOVE_OWN, 3=EDIT_OWN, 4=REMOVE_ANY, 5=EDIT_ANY, 6=WRITE_STICKY, 7=LOCK
  privileges Json @default("[]") // Array of privilege rule objects

  messages BoardMessage[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("Board")
}

model BoardMessage {
  id      Int   @id @default(autoincrement())
  boardId Int   @map("board_id")
  board   Board @relation(fields: [boardId], references: [id], onDelete: Cascade)

  poster      String // Character name who posted (string for legacy compat)
  posterLevel Int      @map("poster_level") // Poster's level at time of posting
  postedAt    DateTime @map("posted_at") // When message was posted (from legacy: time)
  subject     String // Message subject line
  content     String   @db.Text // Message body with color codes
  sticky      Boolean  @default(false) // Sticky messages float to top

  edits BoardMessageEdit[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([boardId])
  @@index([poster])
  @@index([postedAt])
  @@map("BoardMessage")
}

model BoardMessageEdit {
  id        Int          @id @default(autoincrement())
  messageId Int          @map("message_id")
  message   BoardMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  editor   String // Character name who edited
  editedAt DateTime @map("edited_at")

  @@index([messageId])
  @@map("BoardMessageEdit")
}

// ============================================================================
// DISCORD INTEGRATION
// ============================================================================

// Links Discord accounts to Muditor user accounts
model DiscordLink {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  discordId   String   @unique @map("discord_id")
  discordName String   @map("discord_name")
  linkedAt    DateTime @default(now()) @map("linked_at")
  verified    Boolean  @default(false)

  user Users @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("discord_links")
}

// Discord bot configuration for the guild
model DiscordConfig {
  id                    Int     @id @default(1)
  guildId               String  @map("guild_id")
  gossipChannelId       String? @map("gossip_channel_id")
  adminChannelId        String? @map("admin_channel_id")
  announcementChannelId String? @map("announcement_channel_id")
  enabled               Boolean @default(true)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("discord_config")
}

// ============================================================================
// PLAYER REPORTS (Bug, Idea, Typo)
// ============================================================================

model Report {
  id         Int          @id @default(autoincrement())
  reportType ReportType   @map("report_type")
  status     ReportStatus @default(OPEN)

  // Reporter info
  reporterName String  @map("reporter_name") // Character name
  reporterId   String? @map("reporter_id") // User ID if available

  // Location context
  roomZoneId Int? @map("room_zone_id")
  roomId     Int? @map("room_id")

  // Report content
  message String @db.Text

  // Resolution
  resolvedBy String?   @map("resolved_by") // Admin who resolved
  resolvedAt DateTime? @map("resolved_at")
  resolution String?   @db.Text // Resolution notes

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([reportType])
  @@index([status])
  @@index([reporterName])
  @@index([createdAt])
  @@map("reports")
}

// ============================================================================
// COMBAT MESSAGE SYSTEM
// ============================================================================

// Combat messages with array columns for variety (random selection at runtime)
// Supports weapon-type and attack-type specific messages
model CombatMessage {
  id         Int     @id @default(autoincrement())
  hitType    HitType @map("hit_type") // miss, glancing, hit, critical
  attackType String? @map("attack_type") // slash, pierce, crush, magic, NULL = all
  weaponType String? @map("weapon_type") // sword, mace, dagger, NULL = all

  // Message arrays - runtime randomly selects one
  // Placeholders: {actor}, {target}, {damage}, {weapon}
  toActor  String[] @map("to_actor") // ["You miss {target}.", "Your swing goes wide!"]
  toTarget String[] @map("to_target") // ["{actor} misses you.", "{actor}'s attack goes wide."]
  toRoom   String[] @map("to_room") // ["{actor} misses {target}.", "{actor} swings wildly."]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([hitType, attackType, weaponType])
  @@index([hitType])
  @@map("CombatMessage")
}

enum HitType {
  MISS
  GLANCING
  HIT
  CRITICAL
  DEATH // Kill messages
  DODGE // Target dodged
  PARRY // Target parried
  BLOCK // Target blocked with shield
}

// ============================================================================
// QUEST SYSTEM ENUMS
// ============================================================================

enum QuestObjectiveType {
  KILL_MOB // Kill specific mob(s)
  COLLECT_ITEM // Collect specific item(s)
  DELIVER_ITEM // Give item to NPC
  VISIT_ROOM // Visit specific room
  TALK_TO_NPC // Talk to specific NPC
  USE_SKILL // Use a skill/ability
  CUSTOM_LUA // Custom Lua expression
}

enum QuestRewardType {
  EXPERIENCE // XP reward
  ITEM // Object reward
  GOLD // Currency reward
  ABILITY // Learn spell/skill
  SKILL_POINTS // Skill points
}

enum QuestStatus {
  AVAILABLE // Can be accepted
  IN_PROGRESS // Currently active
  COMPLETED // Successfully finished
  FAILED // Failed (time expired, etc.)
  ABANDONED // Player abandoned
}

enum DialogueMatchType {
  EXACT // Must match exactly: "paladin" → only "paladin"
  CONTAINS // Keyword anywhere: "paladin" → "tell me about paladin"
  STARTS_WITH // Response begins with: "yes" → "yes please"
  ANY_RESPONSE // Any text response continues (simple acknowledgments)
  ANY_OF // Match any from list: ["yes", "yep", "sure", "ok", "accept"]
  REGEX // Pattern match for complex cases
}

// Position metadata - defines what each position does and requires
// Positions map to mechanics (C++ hardcoded rules) but metadata is data-driven
model PositionData {
  position        Position         @id
  mechanic        PositionMechanic
  displayName     String           @map("display_name") // "standing", "flying"

  // Lua expression for requirements to enter this position
  // Examples: "has_effect('FLYING')", "has_skill('SWIM')", "has_effect('FLYING') or has_skill('SWIM')"
  // Available: has_effect(name), has_skill(name), skill_level(name), actor.race, actor.level
  entryRequirement String?         @map("entry_requirement")

  // Effects this position applies to actors (e.g., UNDERWATER applies DROWNING)
  appliedEffects  Effect[]         @relation("PositionAppliesEffect")

  // Room presence message template
  defaultPresence String           @map("default_presence") // "{actor} is {position} here."

  // Priority for auto-position selection when multiple are possible
  priority        Int              @default(0)

  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  @@map("PositionData")
}

// Position-based messages (sit, stand, rest, sleep transitions)
model PositionMessage {
  id           Int      @id @default(autoincrement())
  fromPosition Position @map("from_position")
  toPosition   Position @map("to_position")
  command      String? // "sit", "stand", "rest", etc. NULL = any transition

  toActor String[] @map("to_actor") // ["You sit down.", "You take a seat."]
  toRoom  String[] @map("to_room") // ["{actor} sits down.", "{actor} takes a seat."]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([fromPosition, toPosition, command])
  @@map("PositionMessage")
}

// System/error messages with variants
model SystemMessage {
  id       Int      @id @default(autoincrement())
  key      String   @unique // "error_too_heavy", "error_not_here", etc.
  category String // "error", "combat", "magic", "movement"
  messages String[] // ["You can't carry any more.", "That's too heavy for you."]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([category])
  @@map("SystemMessage")
}

// ============================================================================
// QUEST SYSTEM
// ============================================================================

/// How a quest is triggered/started
enum QuestTriggerType {
  MOB // Talk to NPC (traditional quest giver)
  LEVEL // Auto-granted when reaching certain level
  ITEM // Triggered when picking up/examining specific item
  ROOM // Triggered when entering specific room
  SKILL // Triggered when using specific skill
  EVENT // Triggered by game event (seasonal, etc.)
  AUTO // Auto-granted to all characters (tutorial)
  MANUAL // Only granted via GM command or scripts
}

/// Quest definitions - zone-scoped with composite primary key
model Quests {
  zoneId           Int     @map("zone_id")
  id               Int
  name             String // Display name with color codes
  plainName        String  @map("plain_name") // Plain text name for searches
  description      String? @db.Text // Long description for quest log
  shortDescription String? @map("short_description") // One-liner for lists

  // Level requirements
  minLevel Int @default(1) @map("min_level")
  maxLevel Int @default(100) @map("max_level")

  // Flags and state
  repeatable Boolean @default(false)
  shareable  Boolean @default(true) // Can share with group
  autoAccept Boolean @default(false) @map("auto_accept")
  hidden     Boolean @default(false) // Hidden from quest lists

  // Trigger type - how this quest is activated
  triggerType       QuestTriggerType @default(MOB) @map("trigger_type")
  // For MOB trigger: talking to this mob starts the quest
  triggerMobZoneId  Int?             @map("trigger_mob_zone_id")
  triggerMobId      Int?             @map("trigger_mob_id")
  // For LEVEL trigger: level that activates this quest
  triggerLevel      Int?             @map("trigger_level")
  // For ITEM trigger: picking up/examining this item starts the quest
  triggerItemZoneId Int?             @map("trigger_item_zone_id")
  triggerItemId     Int?             @map("trigger_item_id")
  // For ROOM trigger: entering this room starts the quest
  triggerRoomZoneId Int?             @map("trigger_room_zone_id")
  triggerRoomId     Int?             @map("trigger_room_id")
  // For SKILL trigger: using this ability starts the quest
  triggerAbilityId  Int?             @map("trigger_ability_id")
  // For EVENT trigger: which game event activates this quest
  triggerEventId    Int?             @map("trigger_event_id")

  // Time limits
  timeLimitMinutes Int? @map("time_limit_minutes")
  cooldownMinutes  Int? @map("cooldown_minutes")

  // Branching paths - quests with same non-null exclusiveGroup are mutually exclusive
  // Once a quest in a group is accepted, others in that group become unavailable
  exclusiveGroup String? @map("exclusive_group")

  // Availability Lua expression (e.g., "character.class == 'PALADIN'")
  availabilityRequirement String? @map("availability_requirement") @db.Text

  // Tracking
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by")
  updatedBy String?  @map("updated_by")

  // Relations
  phases          QuestPhases[]
  prerequisites   QuestPrerequisites[] @relation("questPrerequisites")
  dependents      QuestPrerequisites[] @relation("prerequisiteQuest")
  characterQuests CharacterQuests[]
  zones           Zones                @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  // Trigger relations - each trigger type has its own target
  triggerMob      Mobs?                @relation("questTriggerMob", fields: [triggerMobZoneId, triggerMobId], references: [zoneId, id])
  triggerItem     Objects?             @relation("questTriggerItem", fields: [triggerItemZoneId, triggerItemId], references: [zoneId, id])
  triggerRoom     Room?                @relation("questTriggerRoom", fields: [triggerRoomZoneId, triggerRoomId], references: [zoneId, id])
  triggerAbility  Ability?             @relation("questTriggerAbility", fields: [triggerAbilityId], references: [id])
  triggerEvent    Events?              @relation("questTriggerEvent", fields: [triggerEventId], references: [id])

  @@id([zoneId, id])
  @@index([plainName])
  @@index([triggerType])
  @@index([triggerMobZoneId, triggerMobId])
  @@index([triggerItemZoneId, triggerItemId])
  @@index([triggerRoomZoneId, triggerRoomId])
  @@index([exclusiveGroup])
  @@map("Quest")
}

/// Sequential phases within a quest - must complete in order
model QuestPhases {
  questZoneId Int     @map("quest_zone_id")
  questId     Int     @map("quest_id")
  id          Int
  name        String // Phase name (e.g., "The Investigation")
  description String? // Phase description
  order       Int     @default(0) // Execution order

  // Relations
  quest      Quests            @relation(fields: [questZoneId, questId], references: [zoneId, id], onDelete: Cascade)
  objectives QuestObjectives[]
  rewards    QuestRewards[]

  @@id([questZoneId, questId, id])
  @@index([questZoneId, questId, order])
  @@map("QuestPhase")
}

/// Steps within a phase - can complete in any order within same phase
model QuestObjectives {
  questZoneId Int @map("quest_zone_id")
  questId     Int @map("quest_id")
  phaseId     Int @map("phase_id")
  id          Int

  objectiveType QuestObjectiveType @map("objective_type")

  // Player-facing description (builder writes this)
  playerDescription String  @map("player_description") // "Kill the furry varmints"
  internalNote      String? @map("internal_note") // Builder note: "10 rats in sewers"
  showProgress      Boolean @default(true) @map("show_progress") // Show "3/10" or just description

  // Count requirements
  requiredCount Int @default(1) @map("required_count")

  // Target specifications (used based on objectiveType)
  targetMobZoneId    Int? @map("target_mob_zone_id")
  targetMobId        Int? @map("target_mob_id")
  targetObjectZoneId Int? @map("target_object_zone_id")
  targetObjectId     Int? @map("target_object_id")
  targetRoomZoneId   Int? @map("target_room_zone_id")
  targetRoomId       Int? @map("target_room_id")
  targetAbilityId    Int? @map("target_ability_id")

  // For DELIVER_ITEM: who to deliver to
  deliverToMobZoneId Int? @map("deliver_to_mob_zone_id")
  deliverToMobId     Int? @map("deliver_to_mob_id")

  // Custom Lua expression for CUSTOM_LUA type
  luaExpression String? @map("lua_expression") @db.Text

  // Relations
  phase             QuestPhases                @relation(fields: [questZoneId, questId, phaseId], references: [questZoneId, questId, id], onDelete: Cascade)
  characterProgress CharacterQuestObjectives[]
  dialogue          QuestDialogue?
  targetMob         Mobs?                      @relation("objectiveTargetMob", fields: [targetMobZoneId, targetMobId], references: [zoneId, id])
  targetObject      Objects?                   @relation("objectiveTargetObject", fields: [targetObjectZoneId, targetObjectId], references: [zoneId, id])
  targetRoom        Room?                      @relation(fields: [targetRoomZoneId, targetRoomId], references: [zoneId, id])
  targetAbility     Ability?                   @relation(fields: [targetAbilityId], references: [id])
  deliverToMob      Mobs?                      @relation("objectiveDeliverTo", fields: [deliverToMobZoneId, deliverToMobId], references: [zoneId, id])

  @@id([questZoneId, questId, phaseId, id])
  @@map("QuestObjective")
}

/// Dialogue attached to TALK_TO_NPC objectives
model QuestDialogue {
  id          Int @id @default(autoincrement())
  questZoneId Int @map("quest_zone_id")
  questId     Int @map("quest_id")
  phaseId     Int @map("phase_id")
  objectiveId Int @map("objective_id")

  // NPC message with markup: "Ask about the <b:gold>paladin</> path?"
  npcMessage String @map("npc_message") @db.Text

  // Response matching
  matchType     DialogueMatchType @default(CONTAINS) @map("match_type")
  matchKeywords String[]          @default([]) @map("match_keywords") // ["paladin", "holy"]

  // Optional link to a full dialogue tree for complex conversations
  dialogueTreeId Int? @map("dialogue_tree_id")

  // Relations
  objective    QuestObjectives @relation(fields: [questZoneId, questId, phaseId, objectiveId], references: [questZoneId, questId, phaseId, id], onDelete: Cascade)
  dialogueTree DialogueTrees?  @relation(fields: [dialogueTreeId], references: [id])

  @@unique([questZoneId, questId, phaseId, objectiveId])
  @@map("QuestDialogue")
}

/// Reusable dialogue trees for complex NPC conversations
model DialogueTrees {
  id          Int     @id @default(autoincrement())
  name        String
  description String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by")
  updatedBy String?  @map("updated_by")

  // Relations
  nodes          DialogueNodes[]
  questDialogues QuestDialogue[]

  @@map("DialogueTree")
}

/// Nodes in a dialogue tree
model DialogueNodes {
  id             Int @id @default(autoincrement())
  dialogueTreeId Int @map("dialogue_tree_id")

  // NPC message with markup
  npcMessage String  @map("npc_message") @db.Text
  order      Int     @default(0) // Order within tree
  isRoot     Boolean @default(false) @map("is_root")
  isTerminal Boolean @default(false) @map("is_terminal") // End of conversation

  // Relations
  dialogueTree      DialogueTrees       @relation(fields: [dialogueTreeId], references: [id], onDelete: Cascade)
  responses         DialogueResponses[] @relation("nodeResponses")
  incomingResponses DialogueResponses[] @relation("responseNextNode")

  @@map("DialogueNode")
}

/// Player response options in dialogue
model DialogueResponses {
  id         Int  @id @default(autoincrement())
  nodeId     Int  @map("node_id") // Parent node
  nextNodeId Int? @map("next_node_id") // Where this response leads

  // Response matching
  matchType     DialogueMatchType @default(CONTAINS) @map("match_type")
  matchKeywords String[]          @default([]) @map("match_keywords")

  // Optional hint shown to player
  displayHint String? @map("display_hint") // "Ask about the paladin path"

  order Int @default(0)

  // Relations
  node     DialogueNodes  @relation("nodeResponses", fields: [nodeId], references: [id], onDelete: Cascade)
  nextNode DialogueNodes? @relation("responseNextNode", fields: [nextNodeId], references: [id])

  @@map("DialogueResponse")
}

/// Quest rewards
model QuestRewards {
  id          Int @id @default(autoincrement())
  questZoneId Int @map("quest_zone_id")
  questId     Int @map("quest_id")
  phaseId     Int @map("phase_id")

  rewardType QuestRewardType @map("reward_type")

  // Reward values (used based on rewardType)
  amount       Int? // For EXPERIENCE, GOLD, SKILL_POINTS
  objectZoneId Int? @map("object_zone_id") // For ITEM
  objectId     Int? @map("object_id")
  abilityId    Int? @map("ability_id") // For ABILITY
  quantity     Int  @default(1) // Item quantity

  // Choice rewards (player picks one from a group)
  choiceGroup Int? @map("choice_group")

  // Optional Lua expression for conditional rewards
  condition String? @db.Text // "character.class == 'PALADIN'"

  // Relations
  phase         QuestPhases @relation(fields: [questZoneId, questId, phaseId], references: [questZoneId, questId, id], onDelete: Cascade)
  rewardObject  Objects?    @relation(fields: [objectZoneId, objectId], references: [zoneId, id])
  rewardAbility Ability?    @relation(fields: [abilityId], references: [id])

  @@index([questZoneId, questId, phaseId])
  @@map("QuestReward")
}

/// Quest prerequisites for chaining
model QuestPrerequisites {
  id                      Int @id @default(autoincrement())
  questZoneId             Int @map("quest_zone_id")
  questId                 Int @map("quest_id")
  prerequisiteQuestZoneId Int @map("prerequisite_quest_zone_id")
  prerequisiteQuestId     Int @map("prerequisite_quest_id")

  // Prerequisite type
  requireCompletion Boolean @default(true) @map("require_completion")

  // Relations
  quest             Quests @relation("questPrerequisites", fields: [questZoneId, questId], references: [zoneId, id], onDelete: Cascade)
  prerequisiteQuest Quests @relation("prerequisiteQuest", fields: [prerequisiteQuestZoneId, prerequisiteQuestId], references: [zoneId, id], onDelete: Cascade)

  @@unique([questZoneId, questId, prerequisiteQuestZoneId, prerequisiteQuestId])
  @@map("QuestPrerequisite")
}

/// Character quest progress (player's quest state)
model CharacterQuests {
  id          String @id @default(uuid())
  characterId String @map("character_id")
  questZoneId Int    @map("quest_zone_id")
  questId     Int    @map("quest_id")

  status         QuestStatus @default(IN_PROGRESS)
  currentPhaseId Int?        @map("current_phase_id")

  // Timestamps
  acceptedAt  DateTime  @default(now()) @map("accepted_at")
  completedAt DateTime? @map("completed_at")
  expiresAt   DateTime? @map("expires_at") // For timed quests

  // Completion count (for repeatable quests)
  completionCount Int @default(0) @map("completion_count")

  // Legacy compatibility: Quest variables as JSON
  variables Json @default("{}")

  // Relations
  character         Characters                 @relation(fields: [characterId], references: [id], onDelete: Cascade)
  quest             Quests                     @relation(fields: [questZoneId, questId], references: [zoneId, id], onDelete: Cascade)
  objectiveProgress CharacterQuestObjectives[]

  @@unique([characterId, questZoneId, questId])
  @@index([characterId, status])
  @@map("CharacterQuest")
}

/// Character objective progress
model CharacterQuestObjectives {
  id               String @id @default(uuid())
  characterQuestId String @map("character_quest_id")
  questZoneId      Int    @map("quest_zone_id")
  questId          Int    @map("quest_id")
  phaseId          Int    @map("phase_id")
  objectiveId      Int    @map("objective_id")

  // Progress tracking
  currentCount Int       @default(0) @map("current_count")
  completed    Boolean   @default(false)
  completedAt  DateTime? @map("completed_at")

  // Relations
  characterQuest CharacterQuests @relation(fields: [characterQuestId], references: [id], onDelete: Cascade)
  objective      QuestObjectives @relation(fields: [questZoneId, questId, phaseId, objectiveId], references: [questZoneId, questId, phaseId, id], onDelete: Cascade)

  @@unique([characterQuestId, questZoneId, questId, phaseId, objectiveId])
  @@map("CharacterQuestObjective")
}

// ============================================================================
// LIQUID TYPES
// Reference data for drink containers - defines appearance and effects
// ============================================================================

model Liquid {
  id        Int    @id @default(autoincrement())
  name      String @unique // Display name: "water", "dark ale", "firebreather"
  alias     String @unique // Keyword for commands: "water", "dark-ale", "firebreather"
  colorDesc String @map("color_desc") // Appearance when unidentified: "clear", "brown", "green"

  // Effects on character conditions when consumed (per sip)
  // Note: is_alcoholic can be derived from drunkEffect > 0
  drunkEffect  Int @default(0) @map("drunk_effect") // How much it intoxicates
  hungerEffect Int @default(0) @map("hunger_effect") // How much it fills stomach
  thirstEffect Int @default(0) @map("thirst_effect") // How much it quenches thirst

  // Optional extended properties
  description String? // Flavor text for examine

  // Applied effects when consumed (via effect system)
  // Individual drink containers can override via ObjectAbilities
  consumeEffects ConsumableEffect[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("Liquids")
}

// ============================================================================
// CONSUMABLE EFFECTS
// Generic table for effects applied when consuming any type of consumable.
// Can be linked to:
//   - Type-level: liquidId (all drinks of this type apply the effect)
//   - Object-level: objectZoneId + objectId (specific item applies the effect)
// This bypasses the Ability/spell system for direct effect application.
// ============================================================================

model ConsumableEffect {
  id       Int   @id @default(autoincrement())
  effectId Int   @map("effect_id")
  chance   Float @default(1.0) // Probability of effect (0.0-1.0)
  level    Int   @default(1) // Effect level/potency
  duration Int? // Duration in ticks (null = effect default)

  // Type-level references (for all items of a type)
  liquidId Int? @map("liquid_id")
  // foodId   Int?     @map("food_id")    // Add when Food model exists

  // Object-level reference (for specific items like potions, scrolls, pills)
  objectZoneId Int? @map("object_zone_id")
  objectId     Int? @map("object_id")

  liquid Liquid?  @relation(fields: [liquidId], references: [id], onDelete: Cascade)
  object Objects? @relation(fields: [objectZoneId, objectId], references: [zoneId, id], onDelete: Cascade)
  effect Effect   @relation(fields: [effectId], references: [id], onDelete: Cascade)

  @@unique([liquidId, effectId])
  @@unique([objectZoneId, objectId, effectId])
  @@map("ConsumableEffects")
}
